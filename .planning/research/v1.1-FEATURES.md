# Feature Landscape: Multi-Agent Coordination (v1.1)

**Domain:** Multi-agent state coherence, DAG scheduling, live feedback, visual differentiation
**Researched:** 2026-02-20
**Confidence:** MEDIUM (ecosystem patterns well-established; Mowism-specific constraints verified against Agent Teams API research)
**Scope:** NEW features for v1.1 only. Existing v1.0 features documented in `FEATURES.md`.

## Context

Mowism v1.0 shipped with single-phase sequential execution, wave-based plan parallelism within a phase, and Agent Teams integration for plan-level workers. v1.1 adds four capabilities that are standard in the multi-agent ecosystem but missing from Mowism:

1. **Shared state across parallel workers** (state coherence)
2. **DAG-based phase scheduling with dependency resolution** (phase-level parallelism)
3. **Live progress feedback from workers to coordinator** (visibility)
4. **Visual differentiation of concurrent agent sessions** (terminal UX)

Each section below categorizes features as table stakes, differentiators, or anti-features based on what the ecosystem (CrewAI, AutoGen, LangGraph, Google ADK, OpenAI Swarm/Agents SDK, human dev teams, Airflow/Prefect) actually does.

---

## 1. Multi-Agent State Coherence

How parallel workers share, read, and update state without corruption or drift.

### Table Stakes

Features users expect from any system with parallel workers operating on shared state.

| Feature | Why Expected | Complexity | Depends On | Notes |
|---------|--------------|------------|------------|-------|
| **Single source of truth for project state** | Every multi-agent framework (CrewAI, LangGraph, ADK) uses a centralized state object or store. Without it, workers drift. Mowism's `.planning/STATE.md` must be authoritative, not duplicated per worktree. | LOW | Existing symlink pattern (v1.0 ARCHITECTURE.md Pattern 5) | Already designed; needs enforcement for multi-phase scenarios |
| **Non-overlapping write keys per worker** | Google ADK's ParallelAgent requires each sub-agent to write to distinct state keys to prevent race conditions. This is the foundational pattern for safe concurrent state mutation. Human teams use CODEOWNERS for the same reason. | MEDIUM | mow-tools.cjs, per-phase state files | Workers write to `phases/XX/status.md`, not to a shared monolithic file. Index file aggregates on read. |
| **Serialized writes to shared state** | OpenAI Swarm passes all context explicitly on handoff because it has no shared state. Systems WITH shared state (LangGraph, ADK) require serialized access. Mowism's mow-tools.cjs advisory locking handles this for STATE.md. | LOW | mow-tools.cjs file locking (exists) | Existing advisory lock pattern is sufficient for the coordinator as single writer |
| **State survives context window compression** | Unique to LLM-agent systems. Claude Code auto-compresses lossy. If state lives only in the coordinator's context, it vanishes. State must be on disk, re-readable after compression. LangGraph solves this with external state checkpointing. | MEDIUM | Disk-based state files | The coordinator must re-read STATE.md and phase status files after any compression event. Design pattern: "state on disk, not in context." |
| **Coordinator state sync on idle** | When the coordinator receives an idle notification, it should re-read state from disk rather than relying on its compressed message history. This is the LangGraph "checkpoint and resume" pattern adapted for Agent Teams' message-based model. | LOW | Idle notification handling | Add a "sync state" step to the coordinator's idle handler |

### Differentiators

Features that would set Mowism apart from other multi-agent coordination tools.

| Feature | Value Proposition | Complexity | Depends On | Notes |
|---------|-------------------|------------|------------|-------|
| **Distributed state with lightweight index** (Candidate A from state coherence todo) | No other Claude Code orchestration tool splits `.planning/` state into per-phase files with a shared index. CrewAI uses monolithic memory; LangGraph uses a centralized state dict; ADK uses session.state with distinct keys. Mowism's per-phase files eliminate merge conflicts entirely while the index gives the coordinator a dashboard view. | HIGH | mow-tools.cjs refactoring, STATE.md redesign | Each phase worker owns `phases/XX/status.md`. Top-level STATE.md becomes a ~30-line index with phase names, statuses, and worker assignments. Coordinator reads index, drills into phase files on demand. |
| **Phase worker autonomy with hierarchical summarization** | Phase workers (spawned as `general-purpose` type with AT tools) manage their own waves independently, only messaging the coordinator at phase-level transitions. This reduces coordinator message volume from O(tasks) to O(phases). No other framework in this space implements hierarchical agent autonomy with explicit message volume management. | HIGH | Nested agent hierarchy (AT tool availability per agent type, confirmed in runtime tests) | The key insight from AGENT-TEAMS-API-RUNTIME.md: `general-purpose` agents have AT tools and can spawn sub-executors. Phase workers are NOT leaf nodes. |
| **Git-native state isolation** | State files live in git, worktrees provide natural isolation, and merge is the reconciliation mechanism. No external database, no vector store, no Redis. The filesystem IS the coordination layer. Human dev teams already do this (each developer's branch is isolated state; merge reconciles). | LOW | Existing git + worktree infrastructure | This is a design philosophy, not a feature to build. But it is a differentiator because every other framework (CrewAI, LangGraph, ADK) requires a runtime state store. |

### Anti-Features

Features that seem useful but create problems for Mowism's architecture.

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| **Real-time shared memory / in-process state** | CrewAI and ADK use in-process shared memory. Mowism workers are independent Claude Code sessions in separate processes. There is no shared memory space. Attempting to simulate it (via a database, Redis, or file watching) adds infrastructure that Claude Code sessions cannot manage. | Use message-based state updates. Workers send structured milestone messages. Coordinator writes to disk. |
| **Event sourcing / append-only log** (Candidate D from state coherence todo) | Theoretically elegant (JSONL per worker, materialized view rebuilt on demand). In practice, Claude Code agents cannot efficiently process JSONL replay. The coordinator would need to read and parse potentially hundreds of events to rebuild state, consuming context window. Event sourcing is designed for programs, not LLMs. | Use the distributed state with index pattern. Each phase status file is a snapshot, not a log. The coordinator reads current state, not history. |
| **Scribe agent for reconciliation** (Candidate B from state coherence todo) | Adds another agent (with its own context window and token cost) whose sole job is writing STATE.md. The scribe becomes a bottleneck for all state updates and adds latency to every phase transition. For Mowism's scale (3-8 concurrent workers), a scribe is over-engineering. | Coordinator writes the index directly. Phase workers write their own phase status files. No intermediary needed. |
| **Cross-worktree file watchers** | Watching `.planning/` files for changes across worktrees would enable reactive state updates. But Claude Code sessions cannot run background file watchers. The Agent Teams API has no file-watch capability. This requires external infrastructure (inotifywait, fswatch) that complicates the setup. | Poll on idle. Coordinator re-reads state files when it receives idle notifications or milestone messages. |

---

## 2. DAG-Based Phase Scheduling

How independent phases execute in parallel with dependency resolution.

### Table Stakes

| Feature | Why Expected | Complexity | Depends On | Notes |
|---------|--------------|------------|------------|-------|
| **Explicit dependency declarations in roadmap** | Airflow, Prefect, LangGraph, and every DAG scheduler requires explicit `depends_on` declarations. The current Mowism roadmap hardwires linear `Depends on: Phase N-1`. Any phase that is truly independent should be declarable as such. | MEDIUM | ROADMAP.md template changes, mow-roadmapper.md updates | Replace linear chain with explicit edges: `depends_on: [1, 2]` or `depends_on: []` for root phases. |
| **Topological sort for execution order** | Kahn's algorithm (BFS-based topological sort) is the standard for task scheduling with dependencies. Every DAG scheduler uses it. Airflow's topological_sort is the reference implementation. This determines which phases can run now vs. which must wait. | LOW | mow-tools.cjs or coordinator logic | Straightforward algorithm. Input: phase dependency graph. Output: execution waves (sets of phases with no unmet dependencies). |
| **Wave grouping of independent phases** | Analogous to Mowism's existing plan-level wave grouping, but at the phase level. Phases with no inter-dependencies form a wave and execute in parallel. This is the scatter-gather pattern from Google ADK's ParallelAgent. | LOW | Topological sort output | The topological sort naturally produces layers. Each layer is a wave. |
| **Dependency validation (cycle detection)** | A DAG must be acyclic. If someone declares `Phase 3 depends on Phase 5` and `Phase 5 depends on Phase 3`, the scheduler must detect this and error. Standard graph theory; every DAG scheduler includes it. | LOW | mow-tools.cjs | Check during roadmap creation. If cycle detected, error with the cycle path. |
| **Partial dependency support** | Phase 5 may depend on Phase 2 but not Phase 3 or 4. The dependency graph must support arbitrary edges, not just "previous phase." Airflow supports this natively with its task dependency API. | LOW | Already implied by explicit dependency declarations | This is inherent to a proper DAG representation. No special implementation needed beyond the dependency field. |

### Differentiators

| Feature | Value Proposition | Complexity | Depends On | Notes |
|---------|-------------------|------------|------------|-------|
| **Roadmapper auto-detects parallelism** | The roadmap creation agent (`mow-roadmapper.md`) analyzes requirements and phase descriptions to determine which phases are genuinely independent vs. which share data/API dependencies. No other Claude Code orchestration tool auto-detects phase independence at roadmap creation time. CrewAI's hierarchical process has a Planner that splits tasks, but it operates at task level, not project phase level. | MEDIUM | mow-roadmapper.md prompt updates | The roadmapper already analyzes requirements. Adding dependency inference means analyzing file overlap, API surface overlap, and data flow between phases. |
| **Visual DAG in roadmap** | Render the phase dependency graph as ASCII art in ROADMAP.md. Human dev teams use Gantt charts; Airflow has a graph view. An ASCII DAG in the roadmap gives the user immediate understanding of what can run in parallel. | LOW | Roadmap template | Simple ASCII rendering: `Phase 1 --> Phase 3`, `Phase 2 --> Phase 3`, showing parallel tracks. |
| **Multi-phase execution command** | `/mow:execute-phase` currently accepts a single phase number. With DAG scheduling, the coordinator should accept multiple phases or auto-detect all runnable phases from the dependency graph. Possible UX: `/mow:execute-phase --parallel` reads the roadmap DAG and launches all phases with satisfied dependencies. | MEDIUM | DAG scheduler, updated execute-phase workflow | Human teams don't manually launch each sprint; the sprint starts automatically when the previous one ends. Similarly, phases should auto-advance when dependencies are satisfied. |
| **Phase-level merge coordination** | When parallel phases complete, their worktree changes need to merge. If phases touch overlapping files, the merge may conflict. The coordinator should detect potential overlap (from plan `files_modified` fields) and warn or sequence accordingly. No other tool in this space handles cross-phase merge conflict prediction. | HIGH | Plan frontmatter analysis, git merge tooling | This is the hardest differentiator. Requires analyzing `files_modified` across phases. If overlap detected, those phases cannot truly be parallel. |

### Anti-Features

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| **Dynamic DAG restructuring at runtime** | LangGraph can dynamically spawn nodes and restructure edges during execution. This is powerful for LLM-driven workflows but adds enormous complexity to state management. If the DAG changes mid-execution, all dependency tracking, wave grouping, and progress reporting must be recalculated. | Fix the DAG at roadmap creation time. If a phase fails or is blocked, the coordinator handles it as an exception, not a DAG restructure. |
| **Automatic phase splitting** | CrewAI's hierarchical process has a Planner that auto-splits tasks into parallelizable subtasks. Auto-splitting phases would mean the system decides how to break up work, which conflicts with Mowism's deliberate phase design (discuss -> plan -> execute). | Phases are defined by the human + roadmapper during `/mow:new-project`. The DAG scheduler respects those boundaries; it does not create new phases. |
| **Priority-based scheduling** | Some DAG schedulers (Airflow) support task priority for resource allocation. With Mowism's constraint of ~5-8 concurrent workers (token cost), priority scheduling adds complexity for marginal benefit. If there are 3 runnable phases and 3 worktrees, all run. No priority needed. | First-come-first-served within a wave. All phases in a wave start simultaneously if resources allow. If resources are constrained, the coordinator picks the lowest-numbered phases first (deterministic, predictable). |

---

## 3. Live Progress Feedback

How workers report status to the coordinator and how the coordinator surfaces it to the user.

### Table Stakes

| Feature | Why Expected | Complexity | Depends On | Notes |
|---------|--------------|------------|------------|-------|
| **Structured milestone messages from workers** | Every multi-agent framework (CrewAI, AutoGen, LangGraph) has inter-agent communication. Workers must send messages at defined checkpoints: task claimed, subtask complete, commit made, error encountered, task done. Without these, the coordinator (and user) are blind. | LOW | Worker prompt engineering, message format convention | Not an API feature -- a prompt instruction. Workers are told to send JSON-structured messages at milestones. |
| **Discrete progress table in coordinator** | The coordinator aggregates milestone messages into a status table. This is the Scrum standup board pattern: each worker has a row showing current task, status, last update. Google ADK's ParallelAgent uses `session.state` keys; Mowism's coordinator prints a table. | LOW | Message parsing in coordinator prompt | The coordinator already prints status updates. Formalizing into a table with columns: Worker, Phase, Plan, Status, Last Activity. |
| **Error escalation from workers** | When a worker hits an unrecoverable error, it must notify the coordinator immediately. The coordinator decides: retry, reassign, or escalate to user. This is standard in every orchestration framework (CrewAI's error handling, AutoGen's fallback patterns). | LOW | Worker error handling prompts | Workers send a structured error message with: error type, what they were doing, what they tried, suggestion for resolution. |
| **Phase completion notification** | When a phase worker finishes all its plans, it sends a completion message with summary data. The coordinator then checks if downstream phases are unblocked. This is the "task complete" callback pattern from Airflow/Prefect. | LOW | Phase worker completion flow | Message format: `{ type: "phase_complete", phase: "03", plans_completed: 4, duration: "12min", summary: "..." }` |

### Differentiators

| Feature | Value Proposition | Complexity | Depends On | Notes |
|---------|-------------------|------------|------------|-------|
| **Hierarchical progress rollup** | Phase workers manage their own internal waves and only report phase-level progress to the coordinator. The coordinator never sees individual plan or task events -- it sees "Phase 3: 2/4 plans complete." This is the O(phases) vs O(tasks) distinction identified in the context window exhaustion risk analysis. No other Claude Code tool implements hierarchical message volume management. | MEDIUM | Phase worker autonomy (nested agent hierarchy) | The coordinator's context stays lean. Phase workers handle their own O(tasks) coordination. Coordinator handles O(phases). |
| **Coordinator dashboard refresh** | After receiving milestone messages, the coordinator prints an updated dashboard showing all active phases, their progress, and any blocked phases. This replaces the "silent until done" experience with periodic status snapshots. Human teams use daily standups for this; Mowism's coordinator does it on every phase-level state change. | LOW | Progress table formatting | Not technically complex, but high UX impact. The user sees the project advancing in real-time(ish). |
| **Quiet worker protocol** | Workers that have been silent for an extended period (no messages in 5+ minutes of wall time) should be flagged in the coordinator dashboard with a "quiet" indicator. The coordinator can then query the task list or send a targeted message to check on the worker. Analogous to a Scrum master checking on a team member who hasn't updated the board. | LOW | Coordinator timestamp tracking | The coordinator tracks when it last heard from each worker. On idle notifications without preceding messages, it flags the worker. |

### Anti-Features

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| **Streaming real-time output from workers** | Agent Teams does NOT provide streaming output from workers. The lead receives discrete messages and idle notifications, not real-time tool calls or file edits. Building a streaming layer on top of message-based communication would require polling (expensive), file watchers (infrastructure), or a custom streaming protocol (enormous effort). | Accept message-based discrete updates. Design the UX around "last known status" snapshots, not real-time feeds. This is the fundamental constraint of Agent Teams. |
| **Progress bars or percentage indicators** | Progress bars imply continuous measurement. But Claude Code agents don't have predictable runtimes -- a "50% complete" claim is meaningless when the remaining 50% might take 10x longer due to unexpected complexity. Human dev teams learned this lesson with story points: they measure effort, not time. | Use discrete milestone counts: "3/5 plans complete" is honest. "60% complete" is deceptive. |
| **Verbose progress chatter** | Workers sending messages after every tool call, file edit, or git commit floods the coordinator's context window. With N workers, each sending 20+ messages, the coordinator's 200k context fills with noise. Auto-compression loses the important messages along with the chatter. | Milestone messages only. Defined checkpoints: claimed, commit, complete, error, blocked. No intermediate chatter. The coordinator receives O(plans) messages per phase, not O(tool_calls). |
| **Centralized logging to a file** | Writing all worker output to a shared log file seems useful for debugging. But Claude Code agents cannot tail a shared log file in real-time, and parsing a large log consumes context. | Workers write their own SUMMARY.md files. The coordinator reads summaries on completion. For debugging failed workers, the user reads the worker's terminal output directly. |

---

## 4. Visual Differentiation of Concurrent Agent Sessions

How the user distinguishes between multiple agent terminals and knows where to direct attention.

### Table Stakes

| Feature | Why Expected | Complexity | Depends On | Notes |
|---------|--------------|------------|------------|-------|
| **Worker self-identification banner** | Every worker prints a colored banner at startup identifying itself: phase name, worker ID, assigned color. This is the minimum for visual differentiation. Agent-viewer (kanban board for Claude Code in tmux) auto-discovers agents but still requires some identification signal. | LOW | Worker spawn prompt, ANSI escape codes | Workers print: `\033[42m [Phase 3: API Server] \033[0m` (green background). This works in any terminal mode. |
| **Orchestrator badge** | The orchestrator/coordinator terminal is always identifiable with a fixed color (red background, per user's preference). This is the "home base" the user returns to for status. | LOW | Coordinator prompt, ANSI escape codes | `\033[41m [ORCHESTRATOR] \033[0m` â€” always red. Never changes. |
| **Color consistency per worker** | Once a worker is assigned green, it stays green for the entire session. Colors are deterministic (based on worker index, not random). The tmux-agent-indicator plugin assigns per-agent icons; Mowism assigns per-agent colors. | LOW | Color palette in coordinator, passed to workers at spawn | Palette: Green(42), Yellow(43), Blue(44), Magenta(45), Cyan(46), Bright White(47). Worker 1 = green, Worker 2 = yellow, etc. Cycle if >6 workers. |
| **Rich notification content in coordinator** | When a worker needs input, the coordinator notification includes: what phase, what kind of input (permission, question, approval), the worker's color badge, and which terminal to switch to. This is the distributed input routing model confirmed by Agent Teams research. | MEDIUM | Structured message format from workers, coordinator notification rendering | Workers must detect when they are blocked and send a structured message: `{ type: "needs_input", input_type: "permission", detail: "wants to run npm install", phase: "03", color: "green" }` |

### Differentiators

| Feature | Value Proposition | Complexity | Depends On | Notes |
|---------|-------------------|------------|------------|-------|
| **tmux pane integration** (optional, tmux-only) | When workers run in tmux mode, Mowism can set per-pane border colors and titles using tmux commands. The tmux-agent-indicator plugin already does this for Claude Code with running/needs-input/done states. Mowism can integrate with or build on this pattern. | MEDIUM | tmux, tmux-agent-indicator (optional dependency) | Not a hard requirement. Works only in tmux mode. Gracefully degrades to banner-only in other modes. |
| **Color-coded status messages** | Workers prefix all milestone messages with their color badge. When the coordinator prints the progress dashboard, each row uses the worker's assigned color. The user can scan the dashboard and immediately correlate colors to terminal windows. No other Claude Code tool does this. | LOW | ANSI escape codes in message formatting | `\033[42m [Phase 3] \033[0m Completed plan 03-02 (commit a1b2c3)` |
| **Terminal switching instructions** | The coordinator notification tells the user exactly which terminal to switch to: "Switch to Terminal 3 (green)" for tmux, or "Press Shift+Down twice" for in-process mode. This bridges the gap between knowing a worker needs input and actually getting to that worker. | LOW | Mode detection (tmux vs in-process vs background) | The coordinator knows the execution mode and the worker index. It computes the switching instruction. |

### Anti-Features

| Anti-Feature | Why Avoid | What to Do Instead |
|--------------|-----------|-------------------|
| **OSC terminal escape sequences for tab/window control** | OSC sequences (like `\033]0;title\007` for window title) work in some terminals (iTerm2, Kitty) but not others (basic xterm, VS Code terminal, Windows Terminal). Relying on them creates a broken experience for most users. | Use ANSI background color codes (`\033[41m`-`\033[47m`) which work in virtually all modern terminals. Set the banner content, not the window title. |
| **Persistent status bar in terminal** | A persistent status bar (like tmux's status line) would show all worker statuses at all times. But Claude Code sessions don't control the terminal chrome. The session IS the terminal. A persistent bar would require terminal multiplexing (tmux) which is not always available. | Print status updates inline when state changes. The user scrolls up to see history. When they want current status, they ask the coordinator or run `/mow:progress`. |
| **Custom terminal emulator** | Building a custom terminal UI (like agent-viewer's web kanban board or Claudeman's WebUI) that shows all agent terminals in one view. This is outside Mowism's scope -- Mowism is a CLI tool that runs inside Claude Code, not a terminal emulator. | Recommend tmux or existing tools (tmux-agent-indicator, agent-viewer) for users who want multi-pane views. Mowism provides the color badges and structured messages; the terminal management is the user's choice. |
| **Animated progress indicators** | Spinners, progress bars, or animated status indicators in the coordinator terminal. Claude Code output is not a TUI -- it's a conversation. Animated elements would be overwritten by the next message and don't survive scrollback. | Static milestone counts. "Phase 3: 3/5 plans complete" is clear, scrollback-friendly, and doesn't require terminal control. |

---

## Feature Dependencies (v1.1 features only)

```
[State Coherence: Distributed state with index]
    |
    +--requires--> mow-tools.cjs refactoring (per-phase state files + index generation)
    |
    +--requires--> STATE.md redesign (from monolithic to index + detail files)
    |
    +--enables--> [DAG Scheduling] (phases need independent state tracking)
    |
    +--enables--> [Live Feedback] (phase workers write to their own status files)
    |
    +--enables--> [Phase Worker Autonomy] (workers own their state, coordinator reads index)

[DAG Scheduling: Dependency graph + topological sort]
    |
    +--requires--> [State Coherence] (parallel phases need isolated state)
    |
    +--requires--> ROADMAP.md template changes (depends_on field per phase)
    |
    +--requires--> mow-roadmapper.md updates (dependency analysis)
    |
    +--enables--> [Multi-phase execution command]
    |
    +--enables--> [Merge coordination] (parallel phases must merge cleanly)

[Live Feedback: Structured milestone messages]
    |
    +--requires--> Worker prompt updates (send structured messages at checkpoints)
    |
    +--requires--> Coordinator prompt updates (parse messages, print dashboard)
    |
    +--requires--> [State Coherence] (coordinator reads state from disk, not context)
    |
    +--enables--> [Visual Differentiation] (messages carry color badges)

[Visual Differentiation: Color-coded terminals]
    |
    +--requires--> Color palette definition (deterministic assignment)
    |
    +--requires--> Worker spawn prompt updates (include color assignment)
    |
    +--requires--> [Live Feedback] (messages must include color metadata)
    |
    +--independent-of--> Agent Teams API (terminal control is shell-level, not AT)

[README Overhaul]
    |
    +--independent-of--> All multi-agent features
    |
    +--should-follow--> v1.1 feature implementation (document what's built)
```

### Dependency Summary

**State coherence MUST come first.** It is the blocking dependency for all three other multi-agent features. Without distributed state with index, parallel phases cannot track independent progress, live feedback has no state to read, and the coordinator's context window fills up trying to manage monolithic state.

**DAG scheduling requires state coherence.** Parallel phases need isolated state files so they don't conflict.

**Live feedback requires state coherence.** The coordinator must re-read state from disk (not context) after compression. The distributed index gives it a lightweight dashboard view.

**Visual differentiation is the most independent.** It only requires a color palette and worker prompt updates. It can be built early as a "quick win" and works without the other features. However, it is most valuable when combined with live feedback (color-coded messages in the coordinator dashboard).

**README overhaul is fully independent** and can proceed in parallel with all multi-agent work.

---

## MVP Recommendation (v1.1)

### Phase 1: State Coherence + README (parallel tracks)

**State coherence track:**
1. Distributed state with index -- per-phase status files, lightweight STATE.md index
2. mow-tools.cjs operations for reading/writing per-phase state
3. Coordinator "sync state" pattern (re-read on idle)

**README track (parallel, independent):**
1. Lifecycle narrative
2. All 34 commands documented
3. Brownfield entry, config/security/troubleshooting sections

**Rationale:** State coherence unblocks everything else. README is fully independent and should not block on multi-agent features.

### Phase 2: DAG Scheduling

1. ROADMAP.md template: `depends_on` field per phase
2. mow-roadmapper.md: dependency analysis in roadmap creation
3. Topological sort in coordinator or mow-tools.cjs
4. Wave grouping at phase level
5. Multi-phase execution command

**Rationale:** DAG scheduling is the core differentiator. It requires state coherence (Phase 1) because parallel phases need isolated state.

### Phase 3: Live Feedback + Visual Differentiation

1. Structured milestone message format (JSON convention)
2. Worker prompt updates (send messages at checkpoints)
3. Color palette and deterministic assignment
4. Worker self-identification banners
5. Coordinator dashboard rendering with color-coded rows
6. Rich notification content for input routing

**Rationale:** These are UX features that build on the execution infrastructure from Phases 1-2. They can be partially implemented alongside Phase 2 (color banners are independent), but the full feedback loop requires the DAG execution infrastructure to be in place.

### Deferred to v1.2+

- tmux pane integration (optional, tmux-only, can be added later)
- Phase-level merge coordination (complex, needs real-world data on merge conflict frequency)
- Dynamic DAG restructuring (anti-feature for now, may reconsider if demand emerges)

---

## Complexity Assessment Summary

| Feature Area | Table Stakes Complexity | Differentiator Complexity | Total Effort |
|-------------|------------------------|---------------------------|-------------|
| State Coherence | LOW-MEDIUM | HIGH (distributed index) | HIGH |
| DAG Scheduling | LOW-MEDIUM | MEDIUM-HIGH (auto-detect, merge coord) | MEDIUM-HIGH |
| Live Feedback | LOW | MEDIUM (hierarchical rollup) | MEDIUM |
| Visual Differentiation | LOW | LOW | LOW |
| **Total v1.1** | | | **HIGH** |

The bulk of the complexity is in state coherence (redesigning STATE.md) and DAG scheduling (roadmap template + coordinator logic). Live feedback and visual differentiation are relatively straightforward prompt engineering and formatting work.

---

## Ecosystem Reference

### How other frameworks handle these four domains:

| Framework | State | DAG | Feedback | Visual |
|-----------|-------|-----|----------|--------|
| **CrewAI** | Shared memory (short-term, long-term, entity), hub-and-spoke communication | Hierarchical process with Planner that auto-splits tasks | Sequential task handoff with context passing | None (no terminal management) |
| **LangGraph** | Centralized state dict, external checkpointing, pause/resume | Native DAG structure, conditional edges, scatter-gather | Graph execution trace, LangSmith observability | None (API-level, no terminal) |
| **Google ADK** | `session.state` with distinct keys per parallel agent, race condition guidance | ParallelAgent + SequentialAgent composable workflow agents | Web UI for step-by-step inspection, event traces | Debug Web UI (not terminal) |
| **AutoGen** | `context_variables` per agent, no built-in persistence | Sequential and concurrent patterns, group chat | Message logs between agents | None |
| **OpenAI Swarm/Agents SDK** | Stateless (all context passed on handoff) | No DAG -- explicit handoffs only | None built-in | None |
| **Human dev teams** | Scrum board (shared state = board, not memory), CODEOWNERS (domain ownership) | Sprint planning with dependency tracking, Gantt charts | Daily standup (bounded periodic summaries), SITREP | Named branches, PR labels, Slack channels per team |
| **Airflow/Prefect** | Task instance state, external DB | Native DAG with topological sort, trigger rules, partial dependencies | Web dashboard, task logs, alerts | DAG graph view, task status colors |
| **Mowism v1.0** | Monolithic STATE.md with symlink to main worktree | Linear phase chain (Phase N depends on Phase N-1) | Silent until done (worker sends SUMMARY on completion) | None |
| **Mowism v1.1 (target)** | Distributed state with index (per-phase files + lightweight index) | DAG with explicit dependencies + topological sort | Structured milestone messages + coordinator dashboard | Color-coded banners + rich notifications |

### Key patterns adopted:

- **From Google ADK:** Distinct write keys per parallel agent (per-phase status files)
- **From LangGraph:** State checkpointing for compression survival, external state store
- **From Airflow:** Topological sort for execution order, trigger rules for dependency resolution
- **From human dev teams:** Standup pattern (periodic bounded summaries), CODEOWNERS (phase ownership), visual identity (branch names -> color badges)
- **From tmux-agent-indicator:** State tracking (running/needs-input/done) with visual feedback
- **From CrewAI:** Hub-and-spoke communication (coordinator is the hub, workers are spokes)

### Key patterns rejected:

- **From LangGraph:** Dynamic DAG restructuring (too complex for Mowism's scale)
- **From CrewAI:** In-process shared memory (workers are separate processes)
- **From OpenAI Swarm:** Stateless design (Mowism needs persistent state across sessions)
- **From Airflow:** Web dashboard (Mowism is CLI-first)
- **From AutoGen:** Group chat pattern (unstructured peer-to-peer messaging floods context)

---

## Sources

### Verified (HIGH confidence)
- [Mowism Agent Teams API Research](file://.planning/research/AGENT-TEAMS-API.md) -- Confirmed constraints: message-based (not streaming), no terminal control, distributed input model
- [Mowism Agent Teams Runtime Tests](file://.planning/research/AGENT-TEAMS-API-RUNTIME.md) -- Confirmed: nested hierarchies possible, context window exhaustion risk, tool availability per agent type
- [Claude Code Agent Teams docs](https://code.claude.com/docs/en/agent-teams) -- Official documentation on team structure, communication, task management
- [Google ADK Parallel Agents](https://google.github.io/adk-docs/agents/workflow-agents/parallel-agents/) -- ParallelAgent implementation, distinct key pattern, scatter-gather
- [Google ADK State](https://google.github.io/adk-docs/sessions/state/) -- session.state management, race condition guidance
- [Airflow DAG documentation](https://airflow.apache.org/docs/apache-airflow/stable/core-concepts/dags.html) -- DAG scheduling, topological sort, trigger rules
- [tmux-agent-indicator](https://github.com/accessd/tmux-agent-indicator) -- Visual feedback for AI agent states in tmux, Claude Code hooks

### Corroborated (MEDIUM confidence)
- [CrewAI Framework 2025 Review](https://latenode.com/blog/ai-frameworks-technical-infrastructure/crewai-framework/crewai-framework-2025-complete-review-of-the-open-source-multi-agent-ai-platform) -- Hierarchical process, memory system, parallel execution
- [LangGraph Multi-Agent Orchestration](https://latenode.com/blog/ai-frameworks-technical-infrastructure/langgraph-multi-agent-orchestration/langgraph-multi-agent-orchestration-complete-framework-guide-architecture-analysis-2025) -- State management, DAG structure, scatter-gather pattern
- [AutoGen Multi-Agent Patterns](https://sparkco.ai/blog/deep-dive-into-autogen-multi-agent-patterns-2025) -- Concurrent patterns, context variables
- [OpenAI Swarm GitHub](https://github.com/openai/swarm) -- Stateless design, explicit handoffs, context variables
- [Agent-Viewer](https://github.com/hallucinogen/agent-viewer) -- Kanban board for Claude Code agents in tmux
- [DAG Task Scheduling Patterns](https://dzone.com/articles/parallelizing-tasks-with-dependencies-design-your) -- Kahn's algorithm, dependency resolution
- [AI Agent Monitoring Best Practices](https://uptimerobot.com/knowledge-hub/monitoring/ai-agent-monitoring-best-practices-tools-and-metrics/) -- Distributed tracing, context propagation
- [Developer's guide to multi-agent patterns in ADK](https://developers.googleblog.com/developers-guide-to-multi-agent-patterns-in-adk/) -- Scatter-gather, fan-out patterns

### WebSearch only (LOW confidence -- flag for validation)
- Agentic Frameworks in 2026 production assessment ([zircon.tech](https://zircon.tech/blog/agentic-frameworks-in-2026-what-actually-works-in-production/))
- Agent orchestration framework comparison ([iterathon.tech](https://iterathon.tech/blog/ai-agent-orchestration-frameworks-2026))
