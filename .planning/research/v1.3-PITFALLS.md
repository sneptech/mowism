# Pitfalls Research: v1.3 tmux Multi-Agent Execution

**Domain:** Adding tmux-based multi-process execution to an existing CLI orchestration tool (Mowism), replacing Agent Teams subprocesses with separate `claude` CLI processes in tmux panes
**Researched:** 2026-02-25
**Confidence:** HIGH (grounded in Claude Code issue tracker evidence, tmux documentation, existing Mowism codebase analysis, and community reports from workmux/dmux/ntm tools that solve the same problem)
**Supersedes:** v1.2 PITFALLS.md (2026-02-24) -- v1.2 pitfalls (worktree path hardcoding, hook reliability, context accumulation, etc.) remain valid and are not repeated here. This document covers NEW pitfalls specific to v1.3's tmux-based multi-agent execution.

---

## Critical Pitfalls

Mistakes that cause broken execution, data loss, or require rewrites. Each pitfall has been observed in real-world tmux+agent implementations.

---

### Pitfall 1: tmux send-keys Race Condition with Shell Initialization

**What goes wrong:**
When creating a new tmux pane and immediately sending a `claude` command via `tmux send-keys`, the command arrives before the shell (bash, zsh, fish) finishes initializing. The keystrokes are either lost entirely, displayed as text but not executed, or garbled into nonsense commands (`mmcd` instead of `cd`). This is documented in [Claude Code issue #23513](https://github.com/anthropics/claude-code/issues/23513) and confirmed as a widespread problem -- users with oh-my-zsh, starship prompt, or any shell configuration that takes >200ms to load are affected. At 4+ simultaneous pane spawns, [issue #23615](https://github.com/anthropics/claude-code/issues/23615) reports 2 out of 4 agents fail to start due to garbled `send-keys`.

**Why it happens:**
`tmux split-window` creates a pane and starts a shell process, but shell initialization (loading .bashrc/.zshrc, plugins, prompt themes) runs asynchronously. `tmux send-keys` dispatches keystrokes to the pane's PTY immediately. There is no mechanism in tmux to block until the shell is interactive. The race window is 0.5-1+ seconds for heavy shell configurations (starship, oh-my-zsh with plugins), and even 50-200ms for minimal configs like fish.

**How to avoid:**
Use `tmux split-window "command"` (or `tmux new-window "command"`) to pass the command directly as the pane's initial process. This runs the command AS the shell process -- no initialization race. The pane runs `claude --worktree ...` directly instead of starting a shell and then typing into it.

Alternatively, if you need a shell (e.g., for user interaction after `claude` exits), use the readiness polling approach: after `split-window`, poll for shell prompt readiness before sending keys:

```bash
# Wait for shell to become interactive (max 5s)
for i in $(seq 1 50); do
  pane_content=$(tmux capture-pane -t "$pane_id" -p 2>/dev/null)
  if echo "$pane_content" | grep -qE '[$#>%]'; then
    break
  fi
  sleep 0.1
done
tmux send-keys -t "$pane_id" "claude ..." Enter
```

**Warning signs:**
- Agents fail to start intermittently (works on retry, fails with fresh shell)
- `zsh: command not found` errors in panes that should be running `claude`
- Pane shows the command text but never executed it
- Works fine with bash but fails with zsh/fish (slower init)

**Phase to address:**
Phase 1 (tmux session/pane lifecycle). This must be solved at the foundation -- every subsequent phase depends on reliable pane creation.

---

### Pitfall 2: Nested tmux Session Detection Failure

**What goes wrong:**
If the user is already running inside a tmux session when they invoke `/mow:auto` (or any command that creates a tmux session), Mowism tries to create a new tmux session from within an existing one. tmux blocks this by default with: `sessions should be nested with care, unset $TMUX to force`. The Mowism command fails silently or with a confusing error, and no workers are spawned.

Worse: if code blindly unsets `$TMUX` to force nesting, the inner session has a different socket path, different server, and different key prefix -- all leading to confusion where commands target the wrong session.

**Why it happens:**
The `$TMUX` environment variable is set by tmux and inherited by all child processes. It contains the socket path (e.g., `/tmp/tmux-1000/default,12345,0`). When a process inherits `$TMUX`, tmux refuses to create a new session to prevent accidental nesting. Most CLI tools don't check for this before attempting tmux operations.

**How to avoid:**
At startup, detect the current tmux state and branch accordingly:

```bash
if [ -n "$TMUX" ]; then
  # Already inside tmux -- create a NEW WINDOW in the existing session
  tmux new-window -n "mow-orchestrator"
  # Split panes within this window, not a new session
else
  # Not in tmux -- create a new session
  tmux new-session -d -s "mow-$project" -n "orchestrator"
  tmux attach-session -t "mow-$project"
fi
```

The architectural decision is: **if already in tmux, use the existing session (new window). If not in tmux, create a session.** Never force-nest.

**Warning signs:**
- "sessions should be nested with care" error appearing in logs
- No tmux session created, but no clear error shown to user
- Workers spawning in the wrong session (user's personal tmux vs Mowism's)

**Phase to address:**
Phase 1 (tmux session/pane lifecycle). The `$TMUX` detection must be the very first thing the session manager does.

---

### Pitfall 3: Orphaned `claude` Processes After Orchestrator Crash

**What goes wrong:**
If the orchestrator (the process managing the tmux session) crashes, gets killed, or the user closes their terminal, the `claude` processes running in tmux panes continue executing. Each `claude` CLI process consumes 270-370MB RAM and 9-18% CPU ([Claude Code issue #11122](https://github.com/anthropics/claude-code/issues/11122)). With 4 workers, that is 1-1.5GB RAM and 40-70% CPU running invisibly in the background. The tmux session also persists (tmux survives terminal closure by design), so the panes continue running even after the user thinks they closed everything.

This is compounded by the fact that tmux only sends SIGHUP to the foreground process when a pane is killed. If `claude` spawns child processes or doesn't handle SIGHUP, those children become orphans ([opencode issue #11225](https://github.com/anomalyco/opencode/issues/11225)).

**Why it happens:**
tmux is designed to persist sessions after detachment -- that is its primary feature. `claude` processes are independent of the orchestrator; they run in their own panes with their own PTYs. There is no parent-child process relationship between the orchestrator and the workers -- they are siblings in the tmux session. If the orchestrator dies, tmux keeps running, and all panes keep running.

**How to avoid:**
Implement defense-in-depth cleanup with multiple layers:

**Layer 1 -- Graceful shutdown:** The orchestrator writes a PID manifest (`/tmp/mow-$session/pids.json`) tracking every `claude` process it spawned. On graceful shutdown (`/mow:close-shop`), iterate PIDs and send SIGTERM.

**Layer 2 -- tmux session cleanup:** Name the tmux session deterministically (`mow-$project-$timestamp`). Provide a `mow cleanup` command that runs `tmux kill-session -t "mow-*"` to clean up stale sessions.

**Layer 3 -- Startup detection:** On `/mow:auto` startup, check for existing `mow-*` tmux sessions. If found, offer: "Found stale session mow-foo with 3 panes still running. Kill and start fresh? (y/n)"

**Layer 4 -- Watchdog (optional):** A lightweight background process that monitors the orchestrator PID. If the orchestrator dies, the watchdog kills all panes in the session after a configurable timeout (e.g., 30 seconds).

**Warning signs:**
- System slowdown after using Mowism multi-agent mode
- `htop` showing multiple `claude` or `node` processes from a previous session
- `tmux ls` showing sessions the user doesn't recognize
- API rate limit errors because stale agents are still making requests

**Phase to address:**
Phase 1 (tmux session/pane lifecycle) for the PID manifest and graceful shutdown. Phase 2 or later for the watchdog and startup detection.

---

### Pitfall 4: Concurrent .planning/ File Writes Causing Data Corruption

**What goes wrong:**
Multiple workers write to files in `.planning/` simultaneously. Two workers completing plans at the same time both try to update STATE.md (or their own STATUS.md files in shared storage). One write overwrites the other. Alternatively, one worker reads STATE.md while another is mid-write, getting a truncated or inconsistent file.

In the current Agent Teams model, the team lead is the single writer for STATE.md and workers write only to their own STATUS.md files. But with tmux-based execution, the coordination model changes: there is no in-process lead mediating writes. Each `claude` process in its pane is fully independent and hits the filesystem directly.

**Why it happens:**
Node.js `fs.writeFileSync` and `fs.readFileSync` are not atomic on most Linux filesystems. `writeFileSync` truncates the file before writing -- any concurrent reader during the truncation window gets an empty file. Two concurrent `writeFileSync` calls to the same file result in undefined behavior (last write wins, but partial writes are possible if the process is interrupted).

Even though workers operate in separate worktrees, certain shared files live in the main repository:
- `.planning/STATE.md` -- project-wide state (the team lead reads/writes this)
- `.planning/config.json` -- project configuration
- `.planning/ROADMAP.md` -- phase status updates

**How to avoid:**
Maintain the single-writer discipline from the Agent Teams model:

1. **Workers write ONLY to their worktree-local files** (STATUS.md, CHECKPOINT.md, phase-specific artifacts). Never to main repo `.planning/` directly.

2. **The orchestrator pane is the single writer for shared state.** Workers signal the orchestrator (via a coordination mechanism -- see below), and the orchestrator serializes writes to STATE.md, ROADMAP.md, etc.

3. **File-based coordination uses atomic operations:**
   - Workers write to a coordination queue directory (`/tmp/mow-$session/events/`)
   - Each event is a new file with a UUID name (atomic create, no overwrite conflict)
   - The orchestrator polls the events directory and processes files sequentially
   - After processing, the orchestrator moves the event file to `processed/`

4. **For STATUS.md files that workers own:** Use write-rename pattern (write to `.STATUS.md.tmp`, then `mv .STATUS.md.tmp STATUS.md`) for atomic updates.

**Warning signs:**
- STATE.md shows incorrect phase status (Phase 3 shows "complete" but its plans are unfinished)
- Missing entries in worktree assignment tables
- "File not found" errors for STATUS.md that should exist
- config.json values reverting to stale values

**Phase to address:**
Phase 2 (file-based worker coordination). This is the core coordination mechanism that replaces Agent Teams' in-process messaging.

---

### Pitfall 5: tmux Session Name Collisions

**What goes wrong:**
Mowism creates a tmux session named `mow-myproject`. The user runs `/mow:auto` again (perhaps after a crash, or in a different terminal). The second invocation tries to create `mow-myproject` but it already exists. tmux silently attaches to the existing session instead of creating a new one, or throws an error. The user now has two orchestrators trying to control the same session, or the old stale session is reused with dead/outdated worker panes.

**Why it happens:**
tmux session names are global to the tmux server. If the session name is derived only from the project name (not including a timestamp or PID), multiple invocations collide.

**How to avoid:**
Use `tmux has-session -t "$session_name" 2>/dev/null` before creation. If the session exists:

```bash
if tmux has-session -t "$session_name" 2>/dev/null; then
  # Session exists -- is it ours?
  # Check for a Mowism marker (a file or environment variable in the session)
  if is_mow_session "$session_name"; then
    prompt_user "Mowism session '$session_name' already exists. Resume or kill?"
  else
    # Collision with a user-created session
    session_name="${session_name}-$(date +%s)"
  fi
fi
```

Name sessions with enough specificity to avoid collisions: `mow-$project_slug-$milestone` (not just `mow`). Store the active session name in `.planning/config.json` so resume detection can find it.

**Warning signs:**
- "duplicate session" errors from tmux
- Unexpected panes appearing in the session (leftover from previous run)
- Two orchestrator processes competing for the same session

**Phase to address:**
Phase 1 (tmux session/pane lifecycle). Session naming strategy is part of session creation.

---

### Pitfall 6: Focus Theft During Pane Creation

**What goes wrong:**
When `tmux split-window` creates a new pane, focus switches to that pane. If the user (or the orchestrator) is typing in the current pane, keystrokes that were in flight go to the new pane instead. This is documented in [Claude Code issue #23615 comment](https://github.com/anthropics/claude-code/issues/23615#issuecomment-3864595681): "if I'm in the middle of typing something and the input focus suddenly changes then at least a few characters of my typing unavoidably go into the new pane/window, which screws up the CLI command to start the new Claude Code."

When spawning 4+ panes rapidly, the focus bounces between panes, and random keystrokes from the user or orchestrator end up in random panes.

**Why it happens:**
`tmux split-window` defaults to focusing the newly created pane. There is no queuing mechanism for keystrokes that arrive during the focus transition.

**How to avoid:**
Use `tmux split-window -d` (the `-d` flag prevents focus change). The new pane is created in the background, and focus stays on the current pane:

```bash
# Wrong: steals focus
tmux split-window -h "claude ..."

# Right: creates pane without stealing focus
tmux split-window -h -d "claude ..."
```

When the orchestrator creates all panes, it should stay focused on its own pane throughout the creation process. Only switch focus explicitly when needed (e.g., after all panes are created, `tmux select-pane -t` to return to orchestrator).

**Warning signs:**
- Random characters appearing in newly created panes
- `claude` commands starting with garbled prefixes
- Orchestrator losing input mid-command
- User accidentally sending text to a worker pane

**Phase to address:**
Phase 1 (tmux session/pane lifecycle). The `-d` flag must be used consistently from the start.

---

### Pitfall 7: Git Operations Colliding Across Worktrees Sharing the Same .git

**What goes wrong:**
Git worktrees share the same underlying `.git` directory (the main repo's `.git/worktrees/` subdirectory). While each worktree has its own index and HEAD, certain git operations touch shared state:

- `git gc` -- rewrites pack files that all worktrees reference
- `git fetch` -- updates shared remote refs
- `git stash` -- writes to shared refs/stash
- `git reflog` -- shared reflog entries
- Branch operations -- creating/deleting branches affects shared refs

When 4 workers simultaneously run `git add` + `git commit` in their respective worktrees, the operations usually succeed because each worktree has its own `index.lock`. But if two workers try to create or delete the same branch, or if a worker runs `git gc` while another is mid-commit, lock conflicts or corruption can occur.

**Why it happens:**
Git worktrees are designed for sequential development across branches, not truly concurrent CI-like parallel operations. The shared `.git` directory is a performance optimization (avoiding full clones) but creates a shared-state bottleneck for certain operations.

**How to avoid:**
1. **Branch naming convention:** Each worker's branch must be unique and deterministic (`phase-$N-$slug`). Workers MUST NOT create branches outside this convention.

2. **Avoid shared-state git operations in workers:** Workers should never run `git gc`, `git prune`, `git stash`, or `git fetch`. These are orchestrator-only operations.

3. **Serialize merge operations:** When workers complete and their branches need merging to main, the orchestrator (not the workers) performs merges sequentially. Never merge two branches in parallel.

4. **Add `.git/worktrees/*/index.lock` cleanup to startup:** If a previous session crashed mid-commit, stale lock files block the new session. Clean them on startup:
   ```bash
   find .git/worktrees/ -name "index.lock" -delete 2>/dev/null
   ```

5. **Consider using `git worktree add --lock`** to create worktrees pre-locked, avoiding the race condition between creation and locking described in the git docs.

**Warning signs:**
- `fatal: Unable to create '.git/worktrees/phase-3/index.lock': File exists` errors
- `error: cannot lock ref 'refs/heads/phase-3': unable to resolve reference` errors
- Merge conflicts appearing in branches that should be independent
- Workers silently failing git operations and continuing with uncommitted changes

**Phase to address:**
Phase 1 for branch naming convention. Phase 2 for merge serialization. Testing/hardening in later phases.

---

### Pitfall 8: Resource Exhaustion from Concurrent Claude Processes

**What goes wrong:**
Each `claude` CLI process consumes 270-370MB RAM and significant CPU. Running 4 workers + 1 orchestrator = 5 processes = 1.3-1.8GB RAM baseline, plus each worker spawns subagents via `Task()` which are additional processes. On a 16GB machine, 4 workers with subagents can consume 3-4GB, leaving limited headroom for the OS, IDE, browser, and other tools.

API rate limits compound the problem. Anthropic enforces per-minute token limits (RPM, ITPM, OTPM). Four workers simultaneously requesting Opus-class completions can hit rate limits within minutes, causing 429 errors and retry cascading.

**Why it happens:**
Each `claude` CLI instance is a full Node.js process with its own V8 heap, event loop, and MCP server connections. There is no shared-process architecture for the CLI -- each instance is independent. Rate limits are per-account, not per-process, so all instances share the same token budget.

**How to avoid:**
1. **Default to 2-3 workers, not 4+.** The "parallelize everything" instinct is wrong for LLM workloads where the bottleneck is API rate limits, not CPU. Research from community tools (workmux, dmux) converges on 2-3 concurrent agents as the sweet spot.

2. **Stagger worker startup.** Don't spawn all 4 panes simultaneously. Spawn one every 5-10 seconds to avoid rate limit spikes at startup (when all workers simultaneously send their initial context to the API).

3. **Monitor and report resource usage.** Show estimated memory usage when spawning workers: "Spawning 4 workers (~1.5GB RAM). Current free: 8GB. Proceed?"

4. **Implement backpressure from rate limits.** If a worker hits a 429 error, it should back off exponentially. The orchestrator should detect repeated 429s and reduce the number of active workers (e.g., tell the newest worker to pause).

5. **Let users configure max workers.** Store in `.planning/config.json`:
   ```json
   { "tmux": { "max_workers": 3 } }
   ```

**Warning signs:**
- System becomes sluggish or unresponsive after spawning workers
- `429 Too Many Requests` errors appearing in worker panes
- Workers taking much longer than expected (CPU-throttled due to thermal limits)
- OOM killer terminating processes on low-RAM systems

**Phase to address:**
Phase 1 for configurable worker count and staggered startup. Phase 2 or later for backpressure and dynamic scaling.

---

## Moderate Pitfalls

---

### Pitfall 9: Terminal State Corruption After Worker Crash

**What goes wrong:**
If a `claude` process crashes mid-output (e.g., due to a Node.js uncaught exception, OOM kill, or SIGKILL), it may leave the terminal in a corrupted state. Common symptoms:
- ANSI escape sequences printed as raw text (e.g., `^[[32m` visible in the pane)
- Terminal echo disabled (user types but nothing appears)
- Line wrapping broken (text overflows pane width)
- Alternate screen buffer left active (content disappears when scrolling)

tmux amplifies this because each pane is a virtual terminal. Invalid escape sequences in one pane can cause tmux to hang processing that pane ([tmux issue #3317](https://github.com/tmux/tmux/issues/3317)), though other panes continue working.

**Why it happens:**
`claude` CLI uses ANSI escape sequences for colors, progress indicators, and TUI elements. If the process is killed between writing an "enter alternate screen" sequence and writing the corresponding "exit alternate screen" sequence, the terminal stays in alternate screen mode. Similar issues occur with cursor visibility, text attributes (bold, color), and mouse mode.

**How to avoid:**
1. **Use `remain-on-exit` for worker panes:** Configure `tmux set-window-option remain-on-exit on` for the Mowism window. When a process exits (cleanly or via crash), the pane shows "Pane is dead" but preserves the output for debugging. Use `tmux respawn-pane` to restart.

2. **Reset terminal state after process exit:** Use a wrapper script that runs `claude` and resets on exit:
   ```bash
   #!/bin/bash
   claude "$@"
   exit_code=$?
   # Reset terminal state
   printf '\033[0m'      # Reset text attributes
   printf '\033[?25h'    # Show cursor
   printf '\033[?1049l'  # Exit alternate screen
   stty sane 2>/dev/null # Reset terminal settings
   exit $exit_code
   ```

3. **Use `tmux send-keys -t $pane "" C-l`** to redraw a pane that appears corrupted without killing the process.

**Warning signs:**
- Pane content looks garbled with escape characters visible
- Pane appears blank but process is still running
- Cursor invisible in a pane after switching to it
- tmux status line shows pane as active but no output is visible

**Phase to address:**
Phase 1 for the wrapper script and `remain-on-exit`. Not architecturally critical but affects usability from day one.

---

### Pitfall 10: User Confusion from Too Many Panes

**What goes wrong:**
With an orchestrator pane + 4 worker panes, the tmux window has 5 panes. On a typical 1920x1080 monitor, each pane gets roughly 38 columns (if horizontal split) or 10 rows (if vertical split). `claude` CLI output requires ~80 columns minimum to be readable. Users lose track of which pane is which, accidentally type into the wrong pane, and can't read truncated output.

The problem is documented in [Claude Code issue #23615](https://github.com/anthropics/claude-code/issues/23615) where users report needing to rearrange panes after agent spawn, and one commenter built an entire custom tmux layout system to address it.

**Why it happens:**
tmux's default split algorithm divides the current pane in half. After 4 splits, panes are tiny. There is no built-in "smart layout" that adjusts based on content needs. Claude Code's own Agent Teams tmux mode has the same problem -- it just keeps splitting.

**How to avoid:**
1. **Use a dedicated tmux window, not splits in the user's existing window.** Create a new window (`tmux new-window`) for the Mowism session. This prevents destroying the user's existing pane layout.

2. **Use tiled layout with named panes:** After creating all panes, run `tmux select-layout tiled` to distribute space evenly. Set pane titles:
   ```bash
   tmux select-pane -t "$pane_id" -T "Phase 3: API Server"
   ```

3. **Default to 2-3 workers on normal screens.** Only allow 4+ workers if the terminal is wide enough (check `tmux display-message -p '#{window_width}'`).

4. **Provide a zoom command.** Teach users about `tmux resize-pane -Z` (prefix + z) to toggle zoom on the current pane. Add this to the orchestrator's startup banner:
   ```
   Tip: Press Ctrl-b z to zoom any pane. Ctrl-b z again to unzoom.
   ```

5. **Consider windows-per-worker instead of panes-per-worker** for 3+ agents. Each worker gets its own tmux window (tab), and the user switches between them with `prefix + n/p`. This gives each worker full terminal width. The orchestrator window shows a status summary.

**Warning signs:**
- User complaining they can't read worker output
- Accidental input to wrong pane causing workers to behave unexpectedly
- Users manually resizing panes after every spawn

**Phase to address:**
Phase 1 for layout strategy. This is a foundational UX decision -- panes vs windows vs hybrid.

---

### Pitfall 11: WorktreeRemove Hook Not Firing on tmux Pane Kill

**What goes wrong:**
When a user kills a tmux pane (`tmux kill-pane` or closes a pane manually), the `claude` process in that pane receives SIGHUP. If `claude` exits cleanly, the WorktreeRemove hook fires and cleanup occurs. But if `claude` doesn't handle SIGHUP gracefully (or if the pane is killed with SIGKILL via `tmux kill-pane -t $pane`), the hook never fires. The worktree remains on disk, the branch remains checked out, and the claim in STATE.md remains active.

This is a known existing concern (documented in `.planning/STATE.md` as a blocker): "WorktreeRemove hook does not fire if `git worktree remove` fails."

**Why it happens:**
Claude Code's WorktreeRemove hook is triggered by `git worktree remove`, not by process exit. If the `claude` process dies without running `git worktree remove`, the hook never fires. tmux `kill-pane` sends SIGHUP to the process, but the process may not perform worktree cleanup in its SIGHUP handler.

**How to avoid:**
1. **Orchestrator-driven cleanup, not hook-driven.** When the orchestrator detects a worker pane has died (via `tmux list-panes` polling or `pane-died` hook), it performs cleanup:
   ```bash
   # Detect dead panes
   dead_panes=$(tmux list-panes -t "$session" -F '#{pane_dead} #{pane_id}' | grep '^1 ')
   for pane in $dead_panes; do
     phase=$(get_phase_for_pane "$pane")
     cleanup_worktree "$phase"
   done
   ```

2. **Periodic stale-worktree detection.** Run `git worktree list` and compare against active panes. Worktrees without matching panes are stale. The existing `cmdWorktreeClean` function handles this -- call it periodically from the orchestrator.

3. **Use tmux `pane-died` hook** (if tmux 3.2+): `tmux set-hook -g pane-died 'run-shell "mow-cleanup-pane %P"'`. This fires when a pane's process exits, regardless of signal.

**Warning signs:**
- `git worktree list` showing worktrees that should have been cleaned up
- "branch already checked out in another worktree" errors when re-running
- Disk space growing from accumulated stale worktrees
- STATE.md showing active claims for workers that no longer exist

**Phase to address:**
Phase 2 (file-based worker coordination) for orchestrator-driven cleanup. This extends the existing stale claim detection from v1.2.

---

### Pitfall 12: Orchestrator-to-Worker Communication Mismatch

**What goes wrong:**
In the Agent Teams model, communication between the lead and workers uses in-process messaging (SendMessage, TaskCreate, TaskUpdate). Workers send structured JSON messages (`phase_complete`, `input_needed`, `error`), and the lead processes them in its event loop. With tmux-based execution, there is no in-process messaging channel. Workers are separate `claude` processes in separate panes with no IPC.

If v1.3 tries to replicate the Agent Teams messaging model using file-based coordination, but the message format, delivery semantics, or polling frequency don't match, workers will miss messages, send duplicate notifications, or the orchestrator will lag behind worker progress.

**Why it happens:**
Agent Teams messaging is synchronous-ish (messages are delivered to the inbox and processed on idle). File-based coordination is inherently asynchronous with no delivery guarantee -- a worker writes a file, and the orchestrator reads it whenever it polls. Polling too frequently wastes CPU; polling too infrequently misses events.

**How to avoid:**
1. **Use filesystem events instead of polling.** On Linux, use `inotifywait` (from `inotify-tools`) to watch the events directory:
   ```bash
   inotifywait -m -e create /tmp/mow-$session/events/ | while read path action file; do
     process_event "$path/$file"
   done
   ```
   This provides near-instant event delivery without polling overhead.

2. **Fallback to polling with configurable interval.** If `inotifywait` is not available (macOS, some minimal Linux installs), fall back to polling every 2-3 seconds. Store the interval in config:
   ```json
   { "tmux": { "poll_interval_ms": 2000 } }
   ```

3. **Define a clear message contract.** Each event file is a JSON file with a fixed schema:
   ```json
   {
     "type": "phase_complete",
     "phase": 3,
     "worker_pane": "%5",
     "timestamp": "2026-02-25T12:00:00Z",
     "data": { "commit": "abc123", "plans_executed": 5 }
   }
   ```
   The schema must match the existing 11 message types from `mow-phase-worker.md` constraints.

4. **Acknowledge events.** After the orchestrator processes an event, it renames the file (e.g., appends `.processed`). Workers can check for acknowledgment if needed (e.g., for `input_needed` -- worker polls for a response file).

**Warning signs:**
- Orchestrator showing stale worker status (worker finished 2 minutes ago but orchestrator still shows "executing")
- Duplicate progress updates in STATE.md
- Workers blocked waiting for acknowledgment that never comes
- Events directory growing unboundedly because events are never processed

**Phase to address:**
Phase 2 (file-based worker coordination). This is the most architecturally significant phase -- it replaces Agent Teams' core communication primitive.

---

### Pitfall 13: Platform-Specific tmux Behavior Breaking Cross-Platform Support

**What goes wrong:**
tmux versions vary significantly across platforms:
- **CachyOS/Arch:** tmux 3.4+ (latest, all features available)
- **Ubuntu 22.04 LTS:** tmux 3.2a (missing some hooks)
- **macOS (Homebrew):** tmux 3.4+ (latest, but macOS-specific UTF-8 issues)
- **macOS (system):** No tmux installed by default
- **WSL:** tmux works but terminal emulator compatibility varies

Features like `pane-died` hooks (tmux 3.2+), `remain-on-exit` (available since tmux 2.x), and `popup` windows (tmux 3.3+) have different availability. Scripts using `tmux display-message -p '#{pane_pid}'` format strings may use format variables not available in older versions.

**Why it happens:**
tmux is not bundled with macOS or Windows. Linux distributions ship wildly different versions. Features are added in minor releases without deprecation warnings.

**How to avoid:**
1. **Check tmux version at startup and gate features:**
   ```bash
   tmux_version=$(tmux -V 2>/dev/null | grep -oE '[0-9]+\.[0-9]+')
   if [ -z "$tmux_version" ]; then
     echo "tmux not installed. Install with: yay -S tmux (Arch) / brew install tmux (macOS)"
     exit 1
   fi
   # Require minimum version
   if [ "$(printf '%s\n' "3.2" "$tmux_version" | sort -V | head -1)" != "3.2" ]; then
     echo "tmux $tmux_version too old. Mowism requires tmux 3.2+."
     exit 1
   fi
   ```

2. **Require tmux 3.2+ as minimum.** This gives us `pane-died` hooks and modern format strings. Document this requirement clearly.

3. **Abstract tmux commands behind a wrapper function** that handles version differences internally:
   ```bash
   mow_tmux_create_pane() {
     if tmux_supports "pane-died-hook"; then
       tmux split-window -d "$@"
       tmux set-hook -t "$session" pane-died "run-shell '...'"
     else
       tmux split-window -d "$@"
       # Fallback: poll for dead panes
     fi
   }
   ```

4. **Test on macOS and Ubuntu LTS** in addition to Arch. The CachyOS-first development approach means features work on Arch but may break on older platforms.

**Warning signs:**
- tmux commands failing with "unknown option" or "unknown format variable"
- Features working on developer's machine but not on user's
- macOS users reporting UTF-8 rendering issues in panes

**Phase to address:**
Phase 1 for minimum version check. Phase 3 or later for comprehensive platform testing.

---

## Technical Debt Patterns

Shortcuts that seem reasonable but create long-term problems.

| Shortcut | Immediate Benefit | Long-term Cost | When Acceptable |
|----------|-------------------|----------------|-----------------|
| Hardcoded `sleep 1` between pane spawns | "Fixes" the send-keys race condition | Fragile: works on fast machines, breaks on slow ones. Shell init time varies by 10x across configs. | Never. Use `split-window "command"` instead. |
| Polling a directory every 500ms for events | Simple implementation, no dependencies | Burns CPU. 2 workers x 10 files x 500ms = 40 reads/second. | Only as fallback when `inotifywait` is unavailable. |
| Storing session state in tmux environment variables | Avoids file I/O for simple state (pane assignments) | Lost on tmux server restart. Hard to debug. Not visible in `cat` like files are. | For ephemeral state only (pane IDs, PIDs). Never for persistent state. |
| Running all git merges in parallel for speed | Faster completion for 4+ workers finishing simultaneously | Merge conflicts, index.lock collisions, corrupted refs. | Never. Serialize merges. |
| Skipping the subprocess fallback for non-tmux environments | Less code to maintain, simpler architecture | Alienates VS Code terminal users, Windows Terminal users, any non-tmux environment. v1.2 Agent Teams subprocess mode works everywhere. | Never. The fallback is a stated requirement. |

## Integration Gotchas

Common mistakes when connecting tmux-based execution to existing Mowism infrastructure.

| Integration | Common Mistake | Correct Approach |
|-------------|----------------|------------------|
| Agent Teams API (`SendMessage`, `TaskCreate`) | Trying to use Agent Teams API from within tmux-spawned `claude` processes. These are NOT Agent Teams teammates -- they are independent processes. | Replace all Agent Teams API calls in workers with file-based event writes. Workers write to `/tmp/mow-$session/events/`. |
| WorktreeCreate hook | Assuming the hook fires when the tmux orchestrator creates a worktree via `git worktree add`. The hook fires when Claude Code creates a worktree via `isolation: worktree`. | If workers are `claude` processes started with `--worktree`, the hook fires as expected. If the orchestrator creates worktrees before spawning `claude`, the hook does NOT fire -- the orchestrator must copy `.planning/` manually. |
| `mow-team-lead.md` agent | Trying to reuse the team lead agent in a tmux pane. The team lead uses `TeamCreate`, `SendMessage`, and other Agent Teams tools that won't be available in a standalone `claude` process. | Write a new orchestrator workflow (`tmux-orchestrator.md`) that replaces Agent Teams API calls with tmux + file-based equivalents. The team lead agent is deprecated for tmux mode. |
| `mow-phase-worker.md` agent | Sending `SendMessage` to the lead from workers. In tmux mode, there is no lead inbox. | Workers write event files instead of calling `SendMessage`. The worker agent needs a conditional path: if Agent Teams is available, use `SendMessage`; if tmux mode, write event files. |
| `.planning/STATE.md` writes from multiple agents | Multiple `claude` processes calling `mow-tools.cjs state update` concurrently. | Only the orchestrator calls `state update`. Workers call `status write` (per-worker file). |
| Dashboard/progress commands | `mow-tools.cjs dashboard` reads STATE.md which may be stale in worker worktrees. | Dashboard always reads from the main repo, not from worktrees. The orchestrator runs dashboard commands. |

## Performance Traps

Patterns that work at small scale but fail as usage grows.

| Trap | Symptoms | Prevention | When It Breaks |
|------|----------|------------|----------------|
| Polling events directory every 500ms with 4+ workers | CPU spikes to 10-15% from orchestrator alone | Use `inotifywait` on Linux, `fswatch` on macOS | > 3 workers generating 10+ events/minute |
| Each worker running `node mow-tools.cjs init ...` on startup (cold Node.js process) | 1-2 second startup delay per worker, multiplied by 4+ workers | Pre-compute init data in orchestrator, pass as environment variable or file | > 4 workers (8+ seconds of staggered init) |
| Workers committing after every plan execution (one commit per plan) | Git operations serialized on shared `.git` lock, workers blocking each other | Batch commits at wave boundaries, not per-plan | > 3 workers executing plans concurrently |
| tmux pane output buffering filling memory | tmux stores scrollback per pane (default 2000 lines). Long-running `claude` sessions generate megabytes of output. 4 panes x 50k lines = significant memory. | Set `set-option -g history-limit 5000` for the Mowism session. Or use `tmux clear-history` periodically. | Multi-hour sessions with verbose output |

## UX Pitfalls

Common user experience mistakes in this domain.

| Pitfall | User Impact | Better Approach |
|---------|-------------|-----------------|
| No visual differentiation between orchestrator and worker panes | User types into worker pane thinking it's the orchestrator, accidentally interfering with worker execution | Color-coded pane borders (tmux 3.2+: `select-pane -P 'bg=colour234'`), prominent banners, pane titles |
| Workers printing verbose output (full plan text, full file diffs) | Panes scroll fast, user can't follow progress across 4 panes simultaneously | Workers print 1-line progress updates. Detailed output goes to log files. User zooms into a pane for details. |
| No indication of which pane needs user input | Discuss-phase requires user input. Worker is blocked but the pane looks the same as an active pane. User doesn't know to switch. | Flash the pane border, ring the terminal bell (`printf '\a'`), or use tmux `display-message` to overlay a notification on the orchestrator pane. |
| No way to see overall progress without reading STATE.md | User has to `cat .planning/STATE.md` or switch to orchestrator pane to check progress | Orchestrator pane shows a live status summary. Or use tmux status line to show "Phase 2: executing [3/5 plans]". |
| `/mow:close-shop` doesn't work from a worker pane | User runs close-shop in a worker's `claude` instance, but that instance has no authority to kill the session | Detect if running in worker context and redirect: "Run /mow:close-shop in the orchestrator pane (leftmost pane)." |

## "Looks Done But Isn't" Checklist

Things that appear complete but are missing critical pieces.

- [ ] **tmux session creation:** Often missing `$TMUX` detection for nested session prevention -- verify by running from inside an existing tmux session
- [ ] **Pane spawn:** Often missing the `-d` flag on `split-window` -- verify no focus theft occurs during spawn
- [ ] **Worker cleanup:** Often missing orphaned process cleanup after crash -- verify by `kill -9` the orchestrator and checking `tmux ls` and `ps aux | grep claude`
- [ ] **File coordination:** Often missing atomic write pattern -- verify by running 4 workers writing events simultaneously and checking for data loss
- [ ] **Graceful shutdown:** Often missing SIGTERM propagation to workers -- verify by running `/mow:close-shop` and confirming all `claude` processes exit
- [ ] **Resume after crash:** Often missing stale session detection -- verify by crashing the orchestrator and running `/mow:auto` again
- [ ] **Non-tmux fallback:** Often missing entirely in early implementation -- verify by running without tmux installed
- [ ] **macOS compatibility:** Often missing because dev machine is Linux -- verify `tmux -V`, `inotifywait` availability, shell init timing

## Recovery Strategies

When pitfalls occur despite prevention, how to recover.

| Pitfall | Recovery Cost | Recovery Steps |
|---------|---------------|----------------|
| Orphaned claude processes | LOW | `tmux kill-session -t "mow-*"` then `pkill -f "claude.*worktree"` |
| Corrupted STATE.md from concurrent writes | MEDIUM | Restore from git (`git checkout HEAD -- .planning/STATE.md`), re-run `mow-tools.cjs health --repair` |
| Stale worktrees from missed cleanup | LOW | `git worktree list`, then `git worktree remove` for each stale entry. Or `mow-tools.cjs worktree clean`. |
| Terminal corruption in a pane | LOW | `tmux respawn-pane -t $pane` or `tmux send-keys -t $pane "reset" Enter` |
| Session name collision | LOW | `tmux kill-session -t $old_session`, then re-run `/mow:auto` |
| Rate limit cascade (all workers hitting 429) | MEDIUM | Kill extra workers (`tmux kill-pane`), wait for rate limit window to pass (1 minute), re-run with fewer workers |
| Focus theft causing garbled commands | LOW | `tmux kill-pane -t $garbled_pane`, re-spawn with `-d` flag |
| inotifywait not available on macOS | LOW | `brew install fswatch`, or accept polling fallback |

## Pitfall-to-Phase Mapping

How roadmap phases should address these pitfalls.

| Pitfall | Prevention Phase | Verification |
|---------|------------------|--------------|
| P1: send-keys race condition | Phase 1 (tmux lifecycle) | Spawn 4 panes on a machine with oh-my-zsh. All 4 should start successfully. |
| P2: Nested tmux detection | Phase 1 (tmux lifecycle) | Run `/mow:auto` from inside an existing tmux session. Should create a new window, not fail. |
| P3: Orphaned processes | Phase 1 (tmux lifecycle) + Phase 2 (coordination) | Kill orchestrator with SIGKILL. Run cleanup command. No stale processes or sessions remain. |
| P4: Concurrent .planning/ writes | Phase 2 (file-based coordination) | Run 4 workers completing simultaneously. STATE.md reflects all completions, no data loss. |
| P5: Session name collisions | Phase 1 (tmux lifecycle) | Run `/mow:auto` twice in quick succession. Second run detects existing session and prompts. |
| P6: Focus theft | Phase 1 (tmux lifecycle) | Spawn 4 panes while typing in orchestrator. No keystrokes should appear in worker panes. |
| P7: Git operation collisions | Phase 1 (naming convention) + Phase 2 (merge serialization) | 4 workers commit simultaneously. No index.lock errors. Merges complete without conflicts. |
| P8: Resource exhaustion | Phase 1 (configurable workers) + Phase 2 (backpressure) | Run on a 8GB RAM machine. System stays responsive. 429 errors trigger worker reduction. |
| P9: Terminal state corruption | Phase 1 (wrapper script) | SIGKILL a worker mid-output. Pane should show "dead" with readable output. Respawn should work. |
| P10: Too many panes | Phase 1 (layout strategy) | Create 4 workers on a 1920x1080 terminal. Each pane should have >= 80 columns OR workers use separate windows. |
| P11: WorktreeRemove hook not firing | Phase 2 (orchestrator-driven cleanup) | Kill a worker pane. Orchestrator should detect dead pane and clean up worktree within 10 seconds. |
| P12: Communication mismatch | Phase 2 (event system) | Worker sends `phase_complete` event. Orchestrator processes it within 3 seconds. STATE.md updated correctly. |
| P13: Platform differences | Phase 1 (version check) + later (testing) | Run on macOS with tmux 3.2. All core features work. Missing inotifywait falls back to polling. |

## Sources

- [Claude Code issue #23513: tmux send-keys race condition with shell initialization](https://github.com/anthropics/claude-code/issues/23513) -- documented race condition between `split-window` and `send-keys`
- [Claude Code issue #23615: Agent teams should spawn in new tmux window, not split current pane](https://github.com/anthropics/claude-code/issues/23615) -- layout destruction, send-keys garbling at scale, focus theft
- [Claude Code issue #11122: Multiple Claude CLI processes accumulate causing high CPU usage](https://github.com/anthropics/claude-code/issues/11122) -- 270-370MB RAM, 9-18% CPU per process
- [OpenCode issue #11225: attach processes not terminated when tmux pane is killed](https://github.com/anomalyco/opencode/issues/11225) -- orphaned process accumulation, SIGHUP handling failure
- [tmux issue #3317: tmux can hang if command outputs invalid ANSI escape sequences](https://github.com/tmux/tmux/issues/3317) -- terminal corruption from malformed escape sequences
- [tmux man page: remain-on-exit, respawn-pane](https://man7.org/linux/man-pages/man1/tmux.1.html) -- process crash recovery primitives
- [tmux nested sessions FAQ](https://koenwoortman.com/tmux-sessions-should-be-nested-with-care-unset-tmux-to-force/) -- $TMUX environment variable detection
- [workmux](https://github.com/raine/workmux) -- git worktrees + tmux windows for parallel dev, cleanup lifecycle (merge+delete+close)
- [dmux](https://github.com/formkit/dmux) -- dev agent multiplexer for git worktrees and claude code
- [ntm](https://github.com/Dicklesworthstone/ntm) -- Named Tmux Manager for multi-agent coordination
- [proper-lockfile npm package](https://www.npmjs.com/package/proper-lockfile) -- file locking for Node.js (considered but not recommended due to advisory lock limitations)
- [Claude Code Agent Teams docs](https://code.claude.com/docs/en/agent-teams) -- display modes, split panes, auto-shutdown behavior
- Existing Mowism codebase: `mow-team-lead.md`, `mow-phase-worker.md`, `mow-worktree-create.sh`, `mow-worktree-remove.sh`, `auto.md` workflow
- Existing Mowism research: `.planning/research/AGENT-TEAMS-API.md`, `.planning/research/AGENT-TEAMS-API-RUNTIME.md`, `.planning/STATE.md` (WorktreeRemove hook concern)

---
*Pitfalls research for: v1.3 tmux Multi-Agent Execution*
*Researched: 2026-02-25*
