---
phase: 10-live-feedback-and-visual-differentiation
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - bin/mow-tools.cjs
  - bin/mow-tools.test.cjs
autonomous: true
requirements: [FEED-02, FEED-04]

must_haves:
  truths:
    - "Dashboard renders a compact summary table with one row per active phase showing progress bar, percentage, activity, and elapsed time"
    - "Completed phases collapse to a single line in the summary table"
    - "Event log shows last N events with phase-level transitions highlighted as bold separators"
    - "Pinned notifications for input_needed and error events persist in the event log until resolved or dismissed"
    - "Dashboard events are stored in NDJSON format with append/read/prune operations"
    - "Dashboard state file tracks pinned notifications for auto-dismiss on worker resume"
  artifacts:
    - path: "bin/mow-tools.cjs"
      provides: "dashboard render, dashboard event add, dashboard event prune subcommands"
      contains: "cmdDashboardRender"
    - path: "bin/mow-tools.test.cjs"
      provides: "Tests for dashboard rendering and event log management"
  key_links:
    - from: "bin/mow-tools.cjs cmdDashboardRender"
      to: "cmdStateActivePhases"
      via: "Dashboard reads Active Phases table for phase status data"
      pattern: "cmdStateActivePhases|parseActivePhasesTable"
    - from: "bin/mow-tools.cjs cmdDashboardRender"
      to: "dashboard-events.ndjson"
      via: "Event log reads from NDJSON file for recent events"
      pattern: "dashboard-events\\.ndjson"
    - from: "bin/mow-tools.cjs cmdDashboardRender"
      to: "dashboard-state.json"
      via: "Pinned notifications and render metadata tracked in state file"
      pattern: "dashboard-state\\.json"
---

<objective>
Implement the live dashboard renderer: summary table with per-phase progress rows, rolling event log with phase-level separator lines, pinned notification system for input routing, and NDJSON-backed event storage with auto-pruning.

Purpose: The orchestrator needs a CLI command to render a live dashboard showing phase progress, recent events, and input routing notifications -- this is the core visual feedback layer (FEED-02) and input routing display (FEED-04).
Output: New `dashboard` subcommands in mow-tools.cjs, dashboard state/event files, extended tests.
</objective>

<execution_context>
@/home/max/.claude/mowism/workflows/execute-plan.md
@/home/max/.claude/mowism/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-live-feedback-and-visual-differentiation/10-RESEARCH.md
@.planning/phases/10-live-feedback-and-visual-differentiation/10-01-SUMMARY.md
@.planning/phases/07-state-coherence-foundation/07-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement dashboard event storage, summary table renderer, and event log renderer</name>
  <files>bin/mow-tools.cjs</files>
  <action>
  **1. Add dashboard event storage functions** (follow `cmdChatLogAppend` pattern):

  - `dashboardEventsPath(cwd)` -- returns `path.join(cwd, '.planning', 'dashboard-events.ndjson')`
  - `dashboardStatePath(cwd)` -- returns `path.join(cwd, '.planning', 'dashboard-state.json')`
  - `readDashboardState(cwd)` -- reads and parses dashboard-state.json, returns `{ pinned: [], last_line_count: 0, last_render_ts: null }` if file doesn't exist
  - `writeDashboardState(cwd, state)` -- writes dashboard-state.json (JSON with indent 2)
  - `readLastNEvents(cwd, n)` -- reads dashboard-events.ndjson, parses each line as JSON, returns last `n` entries. If file doesn't exist, returns empty array.
  - `cmdDashboardEventAdd(cwd, type, phase, detail, raw)` -- appends a JSON event to dashboard-events.ndjson. Event object: `{ type, phase, detail, ts: new Date().toISOString() }`. Auto-prune: if file exceeds 100 events after append, truncate to last 50. Output the appended event.
  - `cmdDashboardEventPrune(cwd, keep, raw)` -- prunes dashboard-events.ndjson to last `keep` entries.

  **2. Add `renderSummaryRow(phase, width)` function:**

  Takes a phase object (from Active Phases table parsing or assembled data) with fields: `{ number, name, status, plans, worker, lastUpdate, activity, elapsed, percent, isBlocked }`.

  Layout for ~80 columns:
  - Phase label: `Phase {N}: {name}` truncated to 25 chars
  - Progress bar: `renderProgressBar(percent, 10, isBlocked, phaseColorCode)` (from Plan 01)
  - Percentage: right-aligned 4 chars (e.g., ` 80%`)
  - Activity: truncated to 22 chars with ellipsis if needed
  - Elapsed time: right-aligned 4 chars (e.g., ` 3m`)
  - Tint the entire row with the phase's 256-color using `color256fg(phaseColor(number).bg, rowText)`

  For completed phases: render as `\u2713 Phase {N} ({elapsed})` -- a single collapsed line, also color-tinted.

  For blocked/waiting phases: activity shows `Awaiting input`, progress bar uses blocked mode.

  **3. Add `renderEventLine(event, width)` function:**

  Takes an event object `{ type, phase, detail, ts }`.

  Format: `{HH:MM} [{Phase N}] {icon} {detail}` truncated to `width`.

  Icons per event type:
  - `task_claimed`: (no icon, just detail text)
  - `commit_made`: `\u2713` (checkmark)
  - `plan_complete`: `\u2713`
  - `phase_complete`: bold separator line `\u2501\u2501\u2501 Phase {N}: Complete ({elapsed}) \u2501\u2501\u2501`
  - `error`: `\u2717` (cross mark)
  - `input_needed`: `\u26A0` (warning) + `INPUT NEEDED: {input_type} -- Switch to Phase {N} terminal`
  - `stage_transition`: arrow or label
  - `plan_created`: (detail text)
  - Other types: detail text only

  Tint the event line with the phase's 256-color.

  For phase_complete and phase-level transitions: render as a bold separator line using `util.styleText('bold', ...)` wrapped in the phase color.

  **4. Add `renderPinnedNotification(pinned, width)` function:**

  Takes `{ phase, input_type, ts, detail }`. Renders as:
  `\u26A0 [{Phase N}] INPUT NEEDED: {input_type} -- Switch to Phase {N} terminal`

  Entire line tinted with phase's 256-color. This line does NOT roll off.

  **5. Add `cmdDashboardRender(cwd, options, raw)` function:**

  Assembles the full dashboard:

  a. Read Active Phases table from STATE.md via internal call to `parseActivePhasesTable` (already exists from Phase 7 Plan 03). If no Active Phases table exists, output "No active phases" and return.

  b. For each active phase, read its STATUS.md (via `cmdStatusRead` internal) to get plan counts and compute percent. Assemble phase row data. For `activity`: scan the last N events from dashboard-events.ndjson (already read in step c, do step c first or cache) to find the most recent event for that phase and use its `detail` field as the `activity` text. Truncate to 22 chars with ellipsis if longer. If no events exist for the phase, use an empty string.

  c. Read last N events (N from `config-get feedback.event_log_count` or default 6).

  d. Read pinned notifications from dashboard-state.json.

  e. Render summary rows for each phase (skip phases with status "not started" -- locked decision: pending/queued phases invisible until a worker starts). Derive `isBlocked` for each phase row: check if the phase has any entry in the `pinned` array of dashboard-state.json (already read in step d). If pinned entries exist for that phase, set `isBlocked = true` — this drives the "Awaiting input" activity text and blocked progress bar fill character.

  f. Render separator line: `\u2500` repeated to width.

  g. Render event lines (non-pinned events).

  h. Render pinned notification lines at the bottom.

  i. If terminal bell enabled (`config-get feedback.terminal_bell`) and there are pinned notifications: append `\x07` (BEL).

  j. Output all lines joined with newlines. In append-only mode (default): just print. Save line count and timestamp in dashboard-state.json.

  k. In `--raw` mode: output JSON `{ lines: N, events: N, pinned: N, phases: N }`.

  **6. Add pinned notification management:**

  - When `cmdDashboardEventAdd` receives an `input_needed` event: auto-add to `pinned` array in dashboard-state.json.
  - When `cmdDashboardEventAdd` receives an `error` event: also auto-add to `pinned` array in dashboard-state.json. This implements the locked decision "Errors and stalls are pinned in the event log — they do NOT roll off until resolved/intervention happens."
  - Auto-dismiss rules for pinned notifications:
    - `input_needed` pins: dismissed when `cmdDashboardEventAdd` receives any subsequent NON-`input_needed`, NON-`error` event for the same phase. This implements "auto-dismiss: pinned notification removed when worker resumes."
    - `error` pins: dismissed when `cmdDashboardEventAdd` receives any subsequent NON-`error`, NON-`input_needed` event for the same phase (i.e., the worker has recovered and sent a normal milestone). This implements "they do NOT roll off until resolved/intervention happens."
    - Manual dismiss: `dashboard clear` removes all pins (session cleanup).
  - Each pinned entry stores `{ phase, type, input_type (if applicable), ts, detail }` so the renderer can distinguish error pins from input_needed pins.

  **7. Add CLI routing:**

  Add `case 'dashboard':` to the CLI switch:
  - `dashboard render [--raw]` -- calls cmdDashboardRender
  - `dashboard event add --type <type> --phase <N> [--detail <text>] [--raw]` -- calls cmdDashboardEventAdd
  - `dashboard event prune --keep <N> [--raw]` -- calls cmdDashboardEventPrune
  - `dashboard state [--raw]` -- outputs current dashboard-state.json contents
  - `dashboard clear` -- removes dashboard-events.ndjson and dashboard-state.json (for session cleanup)
  </action>
  <verify>
  Run: `node bin/mow-tools.cjs dashboard event add --type plan_started --phase 10 --detail "Starting plan 10-01" --raw` -- appends event to NDJSON file.
  Run: `node bin/mow-tools.cjs dashboard event add --type task_claimed --phase 10 --detail "Implementing color helpers" --raw` -- appends second event.
  Run: `FORCE_COLOR=1 node bin/mow-tools.cjs dashboard render` -- outputs dashboard (may show "No active phases" if no Active Phases table exists, which is fine for this verification).
  Run: `node bin/mow-tools.cjs dashboard state --raw` -- outputs JSON with events and state.
  Run: `node bin/mow-tools.cjs dashboard clear` -- removes state files.
  Existing tests still pass: `node bin/mow-tools.test.cjs 2>&1 | tail -5`.
  </verify>
  <done>Dashboard renderer produces summary table + event log + pinned notifications. Event storage supports append, read-last-N, auto-prune, and auto-dismiss. CLI subcommands are accessible.</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for dashboard rendering and event management</name>
  <files>bin/mow-tools.test.cjs</files>
  <action>
  Add a new test section `// --- Phase 10: Dashboard Tests ---` to the test file. Tests:

  **Event storage tests (5 tests):**
  1. `dashboard event add` creates NDJSON file and appends event with correct fields (type, phase, detail, ts)
  2. `dashboard event add` auto-prunes when exceeding 100 events (add 101 events, verify file has 50)
  3. `dashboard event add --type input_needed` auto-pins notification in dashboard-state.json (pinned entry has `type: "input_needed"`)
  4. `dashboard event add --type error` auto-pins notification in dashboard-state.json (pinned entry has `type: "error"`)
  5. `dashboard event add` for a phase with pinned notification (non-input_needed, non-error type) auto-dismisses the pin

  **Dashboard render tests (4 tests):**
  6. `dashboard render --raw` with no active phases returns JSON with `phases: 0`
  7. `dashboard render --raw` after adding events returns JSON with correct event count
  8. `dashboard render` with FORCE_COLOR=1 produces output containing ANSI escape codes
  9. `dashboard render` with NO_COLOR=1 produces output with no ANSI escape codes

  **State management tests (2 tests):**
  10. `dashboard state --raw` returns JSON with pinned array
  11. `dashboard clear` removes both NDJSON and state files

  For tests that need Active Phases table data, create a temporary `.planning/STATE.md` with a mock Active Phases section in the test temp directory.

  Total: 11 new tests.
  </action>
  <verify>
  Run `node bin/mow-tools.test.cjs 2>&1 | tail -5` -- all tests pass, including the 11 new dashboard tests.
  Check test count: should be baseline + 11 (Plan 01) + 11 (Plan 02) = 22 new tests.
  </verify>
  <done>11 new dashboard tests pass covering event storage, auto-pin for input_needed and error, auto-dismiss, dashboard rendering with and without colors, state management, and cleanup. Zero regressions.</done>
</task>

</tasks>

<verification>
1. All tests pass: `node bin/mow-tools.test.cjs`
2. Full dashboard cycle: add 3 events (plan_started, task_claimed, input_needed), render dashboard, verify pinned notification appears, add another event for same phase, verify pin auto-dismissed
3. Event pruning: add 110 events, verify file has 50 after auto-prune
4. Dashboard with NO_COLOR: no escape codes in output
5. Dashboard render with mock Active Phases table: produces summary rows with progress bars
</verification>

<success_criteria>
- `dashboard render` produces a formatted dashboard with summary table and event log
- `dashboard event add` appends to NDJSON with auto-prune at 100 events
- Pinned notifications appear for input_needed events and auto-dismiss on worker resume
- Dashboard respects NO_COLOR and terminal width
- 11+ new tests pass
- Zero regressions on existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/10-live-feedback-and-visual-differentiation/10-02-SUMMARY.md`
</output>
