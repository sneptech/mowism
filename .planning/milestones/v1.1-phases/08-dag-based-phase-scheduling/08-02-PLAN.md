---
phase: 08-dag-based-phase-scheduling
plan: 02
type: tdd
wave: 2
depends_on:
  - 08-01
files_modified:
  - bin/mow-tools.cjs
  - bin/mow-tools.test.cjs
autonomous: true
requirements:
  - DAG-02

must_haves:
  truths:
    - "Running `mow-tools.cjs roadmap analyze-dag` produces correct execution waves from any valid DAG"
    - "Cycle detection identifies circular dependencies and reports the cycle path"
    - "Missing phase references are treated as warnings, not errors, and don't block analysis"
    - "The `ready` field correctly identifies phases whose dependencies are ALL satisfied"
    - "A fully sequential DAG is reported as valid (not flagged as an error)"
  artifacts:
    - path: "bin/mow-tools.cjs"
      provides: "topoGenerations(), cmdRoadmapAnalyzeDag(), analyze-dag subcommand wiring"
      contains: "topoGenerations"
    - path: "bin/mow-tools.test.cjs"
      provides: "DAG topology tests (diamond, linear, independent, complex, cycle)"
      contains: "analyze-dag"
  key_links:
    - from: "bin/mow-tools.cjs (cmdRoadmapAnalyzeDag)"
      to: "cmdRoadmapAnalyze parsing logic"
      via: "reuses phase extraction then adds DAG analysis"
      pattern: "cmdRoadmapAnalyze"
    - from: "bin/mow-tools.cjs (topoGenerations)"
      to: "cmdRoadmapAnalyzeDag"
      via: "called to produce execution waves from edges"
      pattern: "topoGenerations"
    - from: "bin/mow-tools.cjs (roadmap case)"
      to: "cmdRoadmapAnalyzeDag"
      via: "subcommand dispatch"
      pattern: "analyze-dag"
---

<objective>
Implement Kahn's BFS topological sort with generation grouping and wire it into a new `roadmap analyze-dag` CLI subcommand that produces execution waves, ready/blocked status, and DAG validation from ROADMAP.md dependency declarations.

Purpose: This is the core algorithm that enables the team lead and Phase 9 execution engine to determine which phases can run in parallel. The analyze-dag command is the programmatic interface that both humans and other commands consume.

Output: `topoGenerations()` function, `cmdRoadmapAnalyzeDag()` command handler, subcommand dispatch wiring, TDD test suite with 5+ topology scenarios.
</objective>

<execution_context>
@/home/max/.claude/mowism/workflows/execute-plan.md
@/home/max/.claude/mowism/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-dag-based-phase-scheduling/08-RESEARCH.md
@.planning/phases/08-dag-based-phase-scheduling/08-01-SUMMARY.md
@bin/mow-tools.cjs
@bin/mow-tools.test.cjs
</context>

<tasks>

<task type="tdd">
  <name>Task 1: Write failing tests for DAG analysis (RED phase)</name>
  <files>bin/mow-tools.test.cjs</files>
  <action>
Add a new `describe('roadmap analyze-dag command', ...)` test block with the following test cases. Each test writes a ROADMAP.md with specific topology, runs `roadmap analyze-dag`, and asserts the expected output.

**Test 1: Diamond topology** (the v1.1 roadmap pattern)
```
Phase 7 (nothing) --+
                     +--> Phase 9 --> Phase 11
Phase 8 (nothing) --+         |
                     +--> Phase 10 --+
```
Roadmap: Phase 7 depends on Nothing, Phase 8 depends on Nothing, Phase 9 depends on Phase 7 and 8, Phase 10 depends on Phase 7, Phase 11 depends on Phase 7, 8, 9, 10.
Assert: Wave 1 = [7, 8], Wave 2 = [9, 10], Wave 3 = [11]. `is_dag: true`. `fully_sequential: false`.

**Test 2: Linear chain**
Phase 1 -> Phase 2 -> Phase 3.
Assert: Wave 1 = [1], Wave 2 = [2], Wave 3 = [3]. `fully_sequential: true`.

**Test 3: Fully independent**
Phase 1 (nothing), Phase 2 (nothing), Phase 3 (nothing).
Assert: Wave 1 = [1, 2, 3]. Single wave. `fully_sequential: false`.

**Test 4: Cycle detection**
Phase 1 depends on Phase 3, Phase 2 depends on Phase 1, Phase 3 depends on Phase 2.
Assert: `is_dag: false`. `cycle_error` contains the involved phase numbers. `waves: null`.

**Test 5: Missing references**
Phase 1 (nothing), Phase 2 depends on Phase 1 and Phase 99.
Assert: `is_dag: true`. `missing_refs` contains `{ phase: "2", references: "99" }`. Phase 2 still processed (missing ref treated as satisfied). Wave 1 = [1], Wave 2 = [2].

**Test 6: Ready and blocked status**
Write phases with disk_status variations: Phase 1 complete (has PLAN + SUMMARY on disk), Phase 2 depends on Phase 1 (no dir), Phase 3 depends on Phase 1 and 2 (no dir).
Assert: `completed: ["1"]`, `ready: ["2"]`, `blocked: [{ phase: "3", waiting_on: ["2"] }]`.

**Test 7: Missing ROADMAP.md**
Assert: returns `{ error: "ROADMAP.md not found" }`.

All tests should FAIL initially since `roadmap analyze-dag` doesn't exist yet.

Run tests to confirm they fail: `node --test bin/mow-tools.test.cjs 2>&1 | grep -E '(✓|✗|pass|fail)'`
  </action>
  <verify>
Run `node --test bin/mow-tools.test.cjs` -- the new `analyze-dag` tests should all fail (command returns error). Existing tests should still pass.
  </verify>
  <done>
7 failing tests for analyze-dag exist. All existing tests still pass. Test data covers diamond, linear, independent, cycle, missing-ref, ready/blocked, and error topologies.
  </done>
</task>

<task type="tdd">
  <name>Task 2: Implement topoGenerations(), cmdRoadmapAnalyzeDag(), and wire subcommand (GREEN phase)</name>
  <files>bin/mow-tools.cjs</files>
  <action>
**1. Add `topoGenerations(nodes, edges)` function** (place near `parseDependsOn`, before `cmdRoadmapAnalyze`):
```javascript
function topoGenerations(nodes, edges) {
  const inDeg = new Map();
  const adj = new Map();
  for (const n of nodes) { inDeg.set(n, 0); adj.set(n, []); }
  for (const [from, to] of edges) {
    adj.get(from).push(to);
    inDeg.set(to, (inDeg.get(to) || 0) + 1);
  }
  let queue = [...nodes].filter(n => inDeg.get(n) === 0);
  const generations = [];
  let processed = 0;
  while (queue.length > 0) {
    generations.push([...queue]);
    processed += queue.length;
    const next = [];
    for (const n of queue) {
      for (const nb of adj.get(n)) {
        inDeg.set(nb, inDeg.get(nb) - 1);
        if (inDeg.get(nb) === 0) next.push(nb);
      }
    }
    queue = next;
  }
  if (processed !== nodes.length) {
    const cycleNodes = [...inDeg.entries()]
      .filter(([, deg]) => deg > 0)
      .map(([n]) => n);
    throw new Error(`Cycle detected involving: ${cycleNodes.join(', ')}`);
  }
  return generations;
}
```

**2. Add `cmdRoadmapAnalyzeDag(cwd, raw)` function:**

This function:
a. Reads ROADMAP.md and extracts phases using the same parsing logic as `cmdRoadmapAnalyze` (refactor: extract the phase-parsing portion of `cmdRoadmapAnalyze` into a shared internal helper `parseRoadmapPhases(cwd)` that both `cmdRoadmapAnalyze` and `cmdRoadmapAnalyzeDag` can call). If refactoring is too risky, just duplicate the parsing -- it's ~60 lines.
b. Builds nodes (phase numbers) and edges (from `parseDependsOn`) arrays.
c. Tracks missing references (referenced phases not in ROADMAP.md).
d. Calls `topoGenerations(nodes, edges)` wrapped in try/catch for cycle detection.
e. Computes `ready` (deps all satisfied by completed phases, phase not complete) and `blocked` (has unmet deps among non-complete phases).
f. Computes `depended_by` reverse edges for each phase.
g. Returns JSON output matching the schema from 08-RESEARCH.md Pattern 3.

For non-raw output, also print a human-readable text visualization:
```
DAG Analysis:

Wave 1: Phase 7 (complete), Phase 8
Wave 2: Phase 9, Phase 10
Wave 3: Phase 11

Ready to execute: Phase 8
Blocked: Phase 9 (waiting on Phase 8), Phase 11 (waiting on Phase 8, Phase 9, Phase 10)
```

**3. Wire the subcommand** in the main dispatch switch (around line 6751):
After the `else if (subcommand === 'analyze')` block, add:
```javascript
else if (subcommand === 'analyze-dag') {
  cmdRoadmapAnalyzeDag(cwd, raw);
}
```
Update the error message to include `analyze-dag` in available commands.

**4. Run all tests** to confirm the 7 new tests pass (GREEN).
  </action>
  <verify>
Run `node --test bin/mow-tools.test.cjs` -- all tests should pass including the 7 new analyze-dag tests. Also run `node bin/mow-tools.cjs roadmap analyze-dag --raw` from project root and verify the output matches the expected schema with correct waves for the v1.1 roadmap.
  </verify>
  <done>
`topoGenerations()` produces correct execution waves. `roadmap analyze-dag` returns valid JSON with phases, waves, ready, blocked, completed, and validation fields. All 7 DAG topology tests pass. The v1.1 roadmap correctly shows Wave 1 = [7, 8], Wave 2 = [9, 10], Wave 3 = [11].
  </done>
</task>

</tasks>

<verification>
1. `node --test bin/mow-tools.test.cjs` passes all tests
2. `node bin/mow-tools.cjs roadmap analyze-dag --raw` produces valid JSON for project ROADMAP.md
3. `node bin/mow-tools.cjs roadmap analyze-dag` produces human-readable wave visualization
4. Diamond topology: Wave 1 = [7, 8], Wave 2 = [9, 10], Wave 3 = [11]
5. Cycle detection works (throws with cycle path)
6. Missing refs logged but don't block analysis
7. `ready` field correctly identifies actionable phases
8. `fully_sequential` correctly identifies linear chains
</verification>

<success_criteria>
- `topoGenerations()` implements Kahn's BFS with generation grouping (~40 lines, zero dependencies)
- `roadmap analyze-dag` subcommand returns JSON with phases, waves, ready, blocked, completed, validation
- Non-raw mode shows human-readable text visualization
- TDD: 7+ tests covering diamond, linear, independent, cycle, missing-ref, ready/blocked, error
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-dag-based-phase-scheduling/08-02-SUMMARY.md`
</output>
