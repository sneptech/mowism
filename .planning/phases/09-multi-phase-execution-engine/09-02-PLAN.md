---
phase: 09-multi-phase-execution-engine
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - agents/mow-team-lead.md
  - agents/mow-phase-worker.md
autonomous: true
requirements: [EXEC-01, EXEC-02, EXEC-03]

must_haves:
  truths:
    - "Team lead reads DAG from `roadmap analyze-dag --raw`, creates Agent Teams tasks for selected phases, and sets addBlockedBy reflecting the DAG"
    - "Team lead spawns phase workers as `general-purpose` teammates -- each in its own .worktrees/pNN worktree"
    - "Phase workers autonomously run the full discuss-phase -> plan-phase -> execute-phase lifecycle without micromanagement from the lead"
    - "Workers send only phase-level structured messages to the lead (plan_started, plan_complete, phase_complete, error, blocker) -- not task-level chatter"
    - "Lead reacts to worker messages event-driven (no polling) and updates Active Phases table"
    - "Lead shows cascade impact on failure: which downstream phases are blocked by the failed phase"
    - "Circuit breaker trips after N failures (configurable) and halts remaining workers"
    - "Workers write persistent checkpoint files on failure, stay alive for user intervention"
    - "Lead can gracefully cancel a phase -- worker stashes, checkpoints, shuts down"
    - "Merge conflicts delegate to a focused subagent with minimal context"
  artifacts:
    - path: "agents/mow-team-lead.md"
      provides: "Multi-phase orchestration: DAG-to-tasks, phase spawning, merge coordination, circuit breaker, close-shop"
      min_lines: 200
    - path: "agents/mow-phase-worker.md"
      provides: "Phase worker agent definition with full lifecycle autonomy and structured messaging"
      min_lines: 80
  key_links:
    - from: "agents/mow-team-lead.md"
      to: "bin/mow-tools.cjs"
      via: "roadmap analyze-dag --raw, worktree create, worktree merge"
      pattern: "mow-tools\\.cjs"
    - from: "agents/mow-team-lead.md"
      to: "agents/mow-phase-worker.md"
      via: "Task() spawn with subagent_type general-purpose"
      pattern: "general-purpose"
    - from: "agents/mow-phase-worker.md"
      to: "mowism/workflows/execute-phase.md"
      via: "Skill invocation of /mow:execute-phase"
      pattern: "execute-phase"
---

<objective>
Multi-phase team lead orchestrator and autonomous phase worker agent definitions.

Purpose: This is the core orchestration layer. The team lead transforms from a single-phase plan executor into a multi-phase DAG-driven orchestrator that spawns phase workers across worktrees. The phase worker agent runs the full lifecycle (discuss -> plan -> execute) independently, communicating with the lead only at phase milestones. Together these two agent definitions implement the nested agent hierarchy: lead -> phase workers -> plan executors.

Output: Updated mow-team-lead.md with multi-phase orchestration flow. New mow-phase-worker.md agent definition.
</objective>

<execution_context>
@~/.claude/mowism/workflows/execute-plan.md
@~/.claude/mowism/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-multi-phase-execution-engine/09-CONTEXT.md
@.planning/phases/09-multi-phase-execution-engine/09-RESEARCH.md
@.planning/phases/09-multi-phase-execution-engine/09-01-SUMMARY.md
@agents/mow-team-lead.md
@agents/mow-executor.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update mow-team-lead.md for multi-phase DAG-driven orchestration</name>
  <files>agents/mow-team-lead.md</files>
  <action>
Rewrite mow-team-lead.md to support BOTH the existing single-phase plan-level orchestration AND the new multi-phase DAG-driven mode. The mode is determined by the invocation context: if the lead is asked to execute multiple phases, it uses multi-phase mode. If executing a single phase's plans, it uses the existing plan-level mode.

**Structure the file with these sections:**

**1. YAML frontmatter:** Keep existing tools list. Update description to mention multi-phase DAG-driven orchestration.

**2. `<role>` section:** Expand to cover multi-phase responsibilities. The lead is a router and coordinator for both modes.

**3. `<constraints>` section:** Keep existing constraints. Add:
- NEVER poll TaskList in a loop -- event-driven messaging only (locked decision)
- Target ~15% context usage -- state on disk, not in memory
- Independent phases keep executing when one fails (locked decision)
- Workers signal done and stay alive -- do NOT auto-shutdown (locked decision)

**4. `<multi_phase_flow>` section (NEW):** The primary new orchestration flow:

**Step 1: Analyze DAG and present phase selection**
```bash
DAG=$(node ~/.claude/mowism/bin/mow-tools.cjs roadmap analyze-dag --raw)
```
- Parse DAG JSON for `phases`, `waves`, `ready`, `blocked`, `completed`
- Filter to incomplete phases only
- Present to user: which phases to run this session (show DAG structure, ready vs blocked)
- User selects subset

**If user selects phases with incomplete dependencies:**
- Show intimidating warning (locked decision): "WARNING: You are requesting Phase {N} which depends on incomplete Phase(s) {deps}. Dependency work may be missing. Skipping these dependencies means: {specific consequences}. Are you SURE you want to proceed? (yes/no)"
- Only proceed if user confirms

**Step 2: Create team and worktrees**
```
TeamCreate({ team_name: "mow-{project-slug}" })
```
- Record team start in STATE.md via `team-update --action start`
- For each selected phase, run: `node ~/.claude/mowism/bin/mow-tools.cjs worktree create {phase}`
  - For downstream phases (Wave 2+), wait until dependency phases have merged before creating worktree (locked decision: downstream phases branch from merged main)
- If worktree already exists (from previous session), it will be reused with stashed changes restored

**Step 3: Create phase tasks with DAG dependencies**
- Decision (Claude's discretion, per research recommendation): Create ALL selected phase tasks upfront with full DAG dependencies
- Decision (Claude's discretion, per research recommendation): Skip completed phases (don't create pre-done tasks)
- For each selected phase:
  ```
  TaskCreate({
    subject: "Execute Phase {N}: {phase_name}",
    description: "Full lifecycle: discuss-phase -> plan-phase -> execute-phase in worktree .worktrees/p{NN}. Send structured messages to lead at milestones.",
    activeForm: "Executing Phase {N}: {phase_name}"
  })
  ```
- For phases with dependencies within the selected set:
  ```
  TaskUpdate({ taskId: "{downstream_task_id}", addBlockedBy: ["{dependency_task_id}", ...] })
  ```

**Step 4: Spawn phase workers for ready phases**
- Spawn workers only for phases whose dependencies are met (ready in DAG or no blockers in TaskList)
- Each worker is spawned via Task() with:
  - `team_name`: the team name
  - `name`: `"phase-{NN}"` (e.g., `"phase-09"`)
  - `subagent_type`: `"general-purpose"` (confirmed: has all tools including Task() for nested executors)
  - `prompt`: Reference `agents/mow-phase-worker.md` agent definition with phase-specific parameters (phase number, worktree path, phase directory)
  - `run_in_background`: false (NOT background -- workers need terminal access for user interaction during discuss-phase)
- Record each worker in Active Phases table:
  ```bash
  node ~/.claude/mowism/bin/mow-tools.cjs state update-phase-row {phase} --name "{phase_name}" --status "executing" --worker "phase-{NN}" --plans "0/{total}" --last-update "$(date -u +%H:%M)"
  ```

**Step 5: Event-driven monitoring**
- React to messages from workers. Handle by event type using the existing `<message_processing>` section (keep it)
- **On `phase_complete`:**
  1. Update Active Phases: `state update-phase-row {phase} --status complete`
  2. Merge phase branch at wave boundary (batch merge, locked decision) OR immediately (if configured)
     - Run `node ~/.claude/mowism/bin/mow-tools.cjs worktree merge {phase}`
     - If conflicts: spawn a focused merge subagent via Task() with just the conflict diff + resolution context (locked decision: delegate to subagent, not inline)
  3. Check if any downstream phases are now unblocked
     - Defensive unblocking: call TaskList, check each blocked task's dependencies against completed tasks, manually update if needed (since auto-unblocking is unverified)
  4. If downstream phases unblocked AND their worktrees don't exist yet: create worktrees from merged main, spawn workers
- **On `error`:**
  1. Increment circuit breaker counter
  2. Show cascade impact: "Phase {N} failed -- this blocks Phases {blocked_list}. Phase(s) {independent_list} still running independently."
  3. If circuit breaker threshold reached (read from config: `multi_phase.circuit_breaker_threshold`, default 2):
     - Broadcast halt to remaining workers
     - Mark remaining tasks as blocked
     - "Circuit breaker tripped: {N} failures. Remaining workers halted. Please reassess."
  4. Otherwise: independent phases keep executing (locked decision)
- **On `blocker` (worker needs user input for discuss-phase):**
  - Notify user: "Phase {N} worker needs your input for {discuss-phase/checkpoint/etc}. Switch to terminal: phase-{NN}"
  - Worker stays alive, waiting in its terminal

**Step 6: Wave boundary merge (batch mode)**
- When ALL phases in a DAG wave are complete:
  1. Merge each phase branch into main in dependency order
  2. For downstream phases in next wave: create worktrees from post-merge main (gets all prior work)
  3. Spawn workers for newly unblocked phases
- If `multi_phase.merge_timing` is `"immediate"`: merge each phase as it completes (skip batch)

**Step 7: Graceful cancel support**
- User can tell lead to cancel a specific phase
- Lead sends cancel message to the worker
- Worker finishes current atomic operation, stashes uncommitted changes (via `worktree stash`), writes checkpoint file, shuts down
- Distinguished: user cancel = clean checkpoint (reason: `user_cancel`); timeout = checkpoint + warning (reason: `timeout`)

**Step 8: Close-shop (user-initiated)**
- When user runs `/mow:close-shop` or tells lead to wrap up:
  1. Check all workers have signaled done or been cancelled
  2. Run pending merges if any
  3. For each worker: read STATUS.md for deferred items, capture in `.planning/phases/XX/deferred-items.md`
  4. Update STATE.md with final phase statuses
  5. Commit all `.planning/` changes
  6. Send shutdown requests to all workers: `SendMessage({ type: "shutdown_request", ... })`
  7. After all acknowledge: `TeamDelete()`

**5. Keep existing `<orchestration_flow>` section** as `<single_phase_flow>` (renamed) for backward compatibility when executing a single phase's plans. This is the current plan-level orchestration that already works.

**6. Keep existing `<message_processing>` section** unchanged (it already handles all 7 event types).

**7. Keep existing `<error_handling>` section** and extend with multi-phase-specific handling:
- Circuit breaker logic
- Cascade impact reporting
- Independent phases continue on single failure

**Important locked decisions to honor exactly:**
- Workers have full autonomy (discuss -> plan -> execute lifecycle)
- Monitoring is event-driven only, no polling
- Workers signal done and stay alive
- On failure: worker pauses and notifies lead, no automatic retry
- Independent phases keep executing when one fails
- Circuit breaker: configurable threshold (default 2)
- Workers write persistent checkpoint files on failure
- User can override DAG with intimidating warning
- User selects which phases to run this session
- Batch merge at wave boundaries (default), toggleable to immediate
- Downstream phases branch from merged main
- Merge conflicts delegate to focused subagent
  </action>
  <verify>
Read agents/mow-team-lead.md and verify:
1. Contains `<multi_phase_flow>` section with all 8 steps
2. Contains `<single_phase_flow>` (renamed from `<orchestration_flow>`) for backward compatibility
3. References `roadmap analyze-dag --raw` for DAG analysis
4. References `worktree create` for worktree management
5. References `general-purpose` as worker subagent type
6. Contains circuit breaker logic with configurable threshold
7. Contains DAG override warning text
8. References `mow-phase-worker.md` or the agent definition in worker spawn prompts
  </verify>
  <done>
mow-team-lead.md supports both multi-phase DAG-driven orchestration (new) and single-phase plan-level orchestration (existing, renamed). All locked decisions from 09-CONTEXT.md are implemented in the agent definition.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create mow-phase-worker.md autonomous agent definition</name>
  <files>agents/mow-phase-worker.md</files>
  <action>
Create a new agent definition at `agents/mow-phase-worker.md`. This agent is spawned by the team lead as a `general-purpose` teammate. It runs the full phase lifecycle autonomously in its own worktree.

**YAML frontmatter:**
```yaml
---
name: mow-phase-worker
description: Autonomous phase worker for multi-phase execution. Runs full discuss-phase -> plan-phase -> execute-phase lifecycle in its own worktree. Spawned by mow-team-lead as a general-purpose teammate.
tools: Read, Write, Edit, Bash, Grep, Glob, Task, SendMessage, TaskCreate, TaskUpdate, TaskList, TaskGet
color: cyan
---
```

Note: `general-purpose` teammates have ALL tools including Task() for spawning subagents. The phase worker uses Task() to spawn mow-executor subagents for individual plans (nested hierarchy).

**`<role>` section:**
You are a Mowism phase worker. You execute a single phase autonomously in your own worktree. You run the full lifecycle:
1. If phase has no CONTEXT.md: run /mow:discuss-phase (may need user input)
2. If phase has no PLAN files: run /mow:plan-phase
3. Run /mow:execute-phase for all plans

You are a `general-purpose` teammate spawned by the team lead. You communicate with the lead ONLY at phase milestones via structured messages. You handle your own plan-level orchestration internally.

**`<constraints>` section:**
1. NEVER write to STATE.md -- you are NOT the single writer. Write to your own STATUS.md only.
2. NEVER read STATE.md for coordination -- use TaskList and your own STATUS.md.
3. Send structured messages to lead at PHASE-LEVEL milestones only (plan_started, plan_complete, phase_complete, error, blocker). Do NOT send task-level progress.
4. Commit ONLY phase-specific files (SUMMARY.md, STATUS.md) in your worktree. Skip ROADMAP.md and REQUIREMENTS.md updates to avoid merge conflicts (lead handles these after merge).
5. On failure: write checkpoint file, notify lead, STAY ALIVE. Do NOT retry.
6. On completion: signal done, STAY ALIVE. Wait for lead to send shutdown or user to run /mow:close-shop.
7. If new work surfaces during execution, save as context for future (e.g., deferred-items.md in phase directory). Do NOT act on it.

**`<lifecycle>` section:**

**Step 1: Initialize**
- `cd {worktree_path}` (provided in spawn prompt)
- Read phase context: `cat .planning/phases/{phase_dir}/` to see what exists (CONTEXT.md, PLAN files, SUMMARY files)
- Read STATUS.md for any prior progress (resume scenario)

**Step 2: Context gathering (if needed)**
- If no CONTEXT.md exists AND phase requires user discussion:
  - Send blocker message to lead: `node ~/.claude/mowism/bin/mow-tools.cjs message format blocker --phase {phase} --detail "Phase needs discuss-phase context gathering" --action pause --raw`
  - SendMessage to lead with the blocker JSON and summary "Phase {N} needs user input for context"
  - Wait for lead to notify user and for user to interact in this terminal
  - Run discuss-phase workflow
- If CONTEXT.md already exists: skip to Step 3

**Step 3: Planning (if needed)**
- If no PLAN files exist:
  - Run plan-phase workflow (can be autonomous, no user input typically needed)
  - Send plan_started message to lead
- If PLAN files already exist: skip to Step 4

**Step 4: Execute plans**
- Read plan index: `node ~/.claude/mowism/bin/mow-tools.cjs phase-plan-index {phase_number}`
- Group plans into waves
- For each wave:
  - For each plan in wave, spawn mow-executor subagent via Task():
    ```
    Task(
      subagent_type="mow-executor",
      prompt="Execute plan {plan_id} of phase {phase}. Working directory: {worktree_path}. ..."
    )
    ```
  - Wait for all executors in wave to complete
  - Spot-check: verify SUMMARY.md exists for each plan, check commits
  - Send plan_complete message to lead for each completed plan:
    ```bash
    MSG=$(node ~/.claude/mowism/bin/mow-tools.cjs message format plan_complete --phase {phase} --plan {plan_id} --raw)
    ```
    SendMessage to lead with MSG
  - Update STATUS.md with plan progress

**Step 5: Phase complete**
- Verify all plans have SUMMARY.md files
- Send phase_complete message to lead:
  ```bash
  MSG=$(node ~/.claude/mowism/bin/mow-tools.cjs message format phase_complete --phase {phase} --raw)
  ```
  SendMessage to lead with MSG
- Update STATUS.md with final status
- STAY ALIVE -- wait for shutdown signal or close-shop

**`<failure_handling>` section:**

**On executor failure:**
- If a plan executor fails:
  1. Write checkpoint file using template: `node ~/.claude/mowism/bin/mow-tools.cjs template fill checkpoint --phase {phase} --plan {plan} --status failed --worker {name} --worktree {path}`
  2. Fill in the current plan state, uncommitted changes (`git diff --stat`), error context
  3. Write to `.planning/phases/{phase_dir}/{phase}-{plan}-CHECKPOINT.md`
  4. Send error message to lead:
     ```bash
     MSG=$(node ~/.claude/mowism/bin/mow-tools.cjs message format error --phase {phase} --detail "{error_description}" --raw)
     ```
     SendMessage to lead with MSG
  5. STAY ALIVE for user intervention

**On cancel signal from lead:**
- Finish current atomic operation (current task in current plan)
- Stash uncommitted changes: `node ~/.claude/mowism/bin/mow-tools.cjs worktree stash {phase}`
- Write checkpoint with status `cancelled` and reason `user_cancel`
- Acknowledge cancel to lead
- Shut down

**On resume (new worker picking up from checkpoint):**
- Read checkpoint file from `.planning/phases/{phase_dir}/`
- Run quick smoke test on previously-completed plans (locked decision): for each completed SUMMARY.md, verify key files exist and commits are present
- Continue from the checkpoint's plan/task position

**`<messaging_protocol>` section:**

All messages to lead use structured JSON via `mow-tools.cjs message format`. Keep messages phase-level only to minimize lead context usage:

| Milestone | Message Type | When |
|-----------|-------------|------|
| Plan started | `plan_started` | Before spawning executor for a plan |
| Plan complete | `plan_complete` | After executor completes and SUMMARY verified |
| Phase complete | `phase_complete` | After all plans have SUMMARY.md |
| Error | `error` | On executor failure |
| Blocker | `blocker` | When user input needed (discuss-phase, checkpoint) |
  </action>
  <verify>
Read agents/mow-phase-worker.md and verify:
1. Frontmatter has `name: mow-phase-worker`, tools include Task and SendMessage
2. Contains `<lifecycle>` section with 5 steps
3. Contains `<failure_handling>` with checkpoint writing, error messaging, cancel handling
4. Contains `<messaging_protocol>` with the 5 milestone types
5. Contains constraint about never writing STATE.md
6. References `mow-executor` subagent spawning via Task()
7. References `worktree stash` for cancel handling
8. References `template fill checkpoint` for failure recovery
  </verify>
  <done>
mow-phase-worker.md exists with full lifecycle (discuss -> plan -> execute), failure handling with checkpoint files, cancel support with stash, structured messaging protocol, and constraints enforcing single-writer protocol.
  </done>
</task>

</tasks>

<verification>
1. agents/mow-team-lead.md contains `<multi_phase_flow>` with DAG analysis, phase task creation, worker spawning, event monitoring, merge coordination, circuit breaker
2. agents/mow-team-lead.md preserves backward-compatible single-phase mode
3. agents/mow-phase-worker.md contains full lifecycle with 5 steps
4. Phase worker references all structured message types
5. Phase worker references checkpoint template for failure recovery
6. Both agents honor all locked decisions from 09-CONTEXT.md
</verification>

<success_criteria>
- Team lead can analyze DAG, present phase selection to user, create tasks with DAG dependencies, spawn phase workers across worktrees, monitor via events, coordinate merges, and handle failures with circuit breaker
- Phase worker can run full lifecycle autonomously, communicate at phase milestones only, handle failures with checkpoints, and support cancel/resume
- Nested hierarchy: lead -> phase workers (general-purpose) -> plan executors (mow-executor) is documented and wired
- All locked decisions from 09-CONTEXT.md are implemented
</success_criteria>

<output>
After completion, create `.planning/phases/09-multi-phase-execution-engine/09-02-SUMMARY.md`
</output>
