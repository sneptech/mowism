---
phase: 02-worktree-state-and-quality-gates
plan: 04
type: execute
wave: 2
depends_on:
  - 02-02
files_modified:
  - ~/.claude/mowism/workflows/refine-phase.md
autonomous: true
requirements:
  - GATE-04
  - GATE-05
  - GATE-06
  - GATE-08
  - GATE-09

must_haves:
  truths:
    - "Complex tier runs scope-check then simplify + dead-code-sweep + grill-me in parallel, then change-summary, verify-work, update-claude-md"
    - "Algorithmic tier adds prove-it to the parallel stage alongside simplify, dead-code-sweep, grill-me"
    - "Each quality check runs locally in the worktree and writes findings to a file the orchestrator can read"
    - "VERIFICATION-CHAIN-P{phase}.md index file links to all per-check findings with result summary"
    - "change-summary prompt includes reconciliation: reads all prior findings and notes conflicting recommendations"
  artifacts:
    - path: "~/.claude/mowism/workflows/refine-phase.md"
      provides: "Complete quality chain with all tiers, VERIFICATION-CHAIN index, reconciliation"
      contains: "Stage 2"
  key_links:
    - from: "~/.claude/mowism/workflows/refine-phase.md"
      to: "quality skill commands"
      via: "Task() calls referencing /simplify, /dead-code-sweep, /grill-me, /prove-it"
      pattern: "Task\\("
    - from: "~/.claude/mowism/workflows/refine-phase.md"
      to: "VERIFICATION-CHAIN-P{phase}.md"
      via: "index file generation after chain completes"
      pattern: "VERIFICATION-CHAIN"
    - from: "change-summary Task() prompt"
      to: "all Stage 1+2 findings files"
      via: "prompt instruction to read findings and note conflicts"
      pattern: "conflicting recommendations"
---

<objective>
Extend the refine-phase workflow (created in Plan 02-02) with complex and algorithmic tier parallel stages, VERIFICATION-CHAIN index file generation, STATE.md verification results update, and reconciliation via change-summary.

Purpose: Completes the quality gate system -- all tiers are functional, findings are persisted in structured files, and conflicting recommendations from parallel checks are reconciled.

Output: Complete refine-phase workflow with all tiers, VERIFICATION-CHAIN output, and STATE.md integration.
</objective>

<execution_context>
@/home/max/.claude/mowism/workflows/execute-plan.md
@/home/max/.claude/mowism/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-worktree-state-and-quality-gates/02-RESEARCH.md
@.planning/phases/02-worktree-state-and-quality-gates/02-02-SUMMARY.md
@/home/max/.claude/mowism/workflows/refine-phase.md
@/home/max/git/mowism/commands/simplify.md
@/home/max/git/mowism/commands/dead-code-sweep.md
@/home/max/git/mowism/commands/grill-me.md
@/home/max/git/mowism/commands/prove-it.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add complex and algorithmic tier parallel stages to refine-phase workflow</name>
  <files>~/.claude/mowism/workflows/refine-phase.md</files>
  <action>
Replace the `<!-- Stage 2 (Parallel): Added by Plan 02-04 -->` placeholder in `~/.claude/mowism/workflows/refine-phase.md` with the full Stage 2 implementation.

**Stage 2 (Parallel): Quality Checks** -- runs only for complex and algorithmic tiers.

For **complex tier**, spawn 3 parallel Task() calls in a single message block:

```
# All three spawn in one message = parallel execution
simplify_result = Task(
  prompt="
    Run /simplify on the changes made during Phase {phase_number}.

    Context: Phase {phase_number}: {phase_name}
    Phase directory: {phase_dir}

    Read the SUMMARY.md files in {phase_dir} to understand what was built.
    Then examine the code changes.

    After running simplify, write your findings to:
    {phase_dir}/VERIFICATION-CHAIN-P{phase_number}/simplify.md

    Format with YAML frontmatter:
    ---
    check: simplify
    phase: {phase_number}
    result: pass|request-changes
    date: {ISO timestamp}
    duration: (record how long this took)
    findings_count: (number of simplification opportunities found)
    ---

    ## Simplify Findings
    [full output]
  ",
  description="Simplify: Phase {phase_number}"
)

dead_code_result = Task(
  prompt="
    Run /dead-code-sweep on the changes made during Phase {phase_number}.
    [Same structure as simplify but for dead-code-sweep skill]
    Write to: {phase_dir}/VERIFICATION-CHAIN-P{phase_number}/dead-code-sweep.md
  ",
  description="Dead code sweep: Phase {phase_number}"
)

grill_result = Task(
  prompt="
    Run /grill-me on the changes made during Phase {phase_number}.
    [Same structure but for grill-me skill]
    Write to: {phase_dir}/VERIFICATION-CHAIN-P{phase_number}/grill-me.md
  ",
  description="Grill me: Phase {phase_number}"
)
```

For **algorithmic tier**, spawn 4 parallel Task() calls (same 3 as complex PLUS prove-it):

```
prove_result = Task(
  prompt="
    Run /prove-it on the changes made during Phase {phase_number}.
    Focus on algorithmic correctness, edge cases, and formal reasoning.
    [Same structure but for prove-it skill]
    Write to: {phase_dir}/VERIFICATION-CHAIN-P{phase_number}/prove-it.md
  ",
  description="Prove it: Phase {phase_number}"
)
# Plus the same 3 from complex tier
```

Apply the same resilience wrapper from Plan 02-02 to each Task() call: record start time, retry once on transient failure, continue on error, write error to findings file.

**Update the change-summary Stage 3 prompt** to include reconciliation (GATE-09):

Add to the change-summary Task() prompt:
```
IMPORTANT: Before generating your summary, read ALL findings files in
{phase_dir}/VERIFICATION-CHAIN-P{phase_number}/ that exist from prior checks.

If any checks have contradictory recommendations (e.g., simplify says
"remove this abstraction" while grill-me says "add more error handling to
this abstraction"), note the conflict explicitly and recommend which to
follow based on Phase {phase_number}'s goals. Conflicts between quality
checks are normal -- your job is to synthesize, not ignore.

Include a "## Reconciliation" section at the end of your summary if any
conflicts were found.
```

This makes change-summary the natural reconciliation point per research recommendation. No separate reconciliation step needed.

**Update the `execute_chain` step** to branch on tier:
- minimum: Stage 1, 3, 4, 5 (no Stage 2) -- already implemented in Plan 02-02
- complex: Stage 1, Stage 2 (3 parallel), Stage 3, 4, 5
- algorithmic: Stage 1, Stage 2 (4 parallel), Stage 3, 4, 5

**Update `report_results`** to include Stage 2 checks in the summary table when applicable.
  </action>
  <verify>
`grep -c "Task(" ~/.claude/mowism/workflows/refine-phase.md` shows 8 (4 minimum + 4 additional for complex/algorithmic, deduplicated to 8 total Task patterns).
`grep "Stage 2" ~/.claude/mowism/workflows/refine-phase.md` shows Stage 2 content (not just placeholder).
`grep "Reconciliation" ~/.claude/mowism/workflows/refine-phase.md` shows reconciliation instruction in change-summary prompt.
`grep "prove-it" ~/.claude/mowism/workflows/refine-phase.md` shows prove-it in algorithmic tier.
  </verify>
  <done>Complex tier spawns simplify + dead-code-sweep + grill-me in parallel. Algorithmic tier adds prove-it. Change-summary includes reconciliation of conflicting findings. All tiers functional.</done>
</task>

<task type="auto">
  <name>Task 2: Add VERIFICATION-CHAIN index generation and STATE.md verification results update</name>
  <files>~/.claude/mowism/workflows/refine-phase.md</files>
  <action>
Add two new steps to the refine-phase workflow AFTER `report_results`:

**Step 5: `write_verification_chain_index`**

After the chain completes, generate the VERIFICATION-CHAIN-P{phase}.md index file at `{phase_dir}/VERIFICATION-CHAIN-P{phase_number}.md`:

```markdown
# Verification Chain: Phase {phase_number}

**Date:** {ISO date}
**Tier:** {selected tier}
**Result:** {overall result: pass if all pass, fail if any fail, mixed if some error}

## Chain Summary

| # | Check | Result | Duration | Findings |
|---|-------|--------|----------|----------|
| 1 | scope-check | {result} | {duration} | [scope-check.md](VERIFICATION-CHAIN-P{phase}/scope-check.md) |
| 2 | simplify | {result} | {duration} | [simplify.md](VERIFICATION-CHAIN-P{phase}/simplify.md) |
[...for each check that ran]

## Blockers
{List any checks with result "fail" or "request-changes" with severity, or "None" if all pass}

## Overall Verdict
{PASS / FAIL / MIXED with explanation}
```

The index is generated by the orchestrator (not a subagent) from the collected results. Read each findings file's frontmatter to extract result, duration, and findings_count. This keeps the orchestrator lean -- it only reads frontmatter, not full findings.

For checks that didn't run (e.g., prove-it on minimum tier): omit from the table.
For checks that errored: show "error" as result with a note.

**Step 6: `update_state`**

Call mow-tools.cjs to record the verification result:
```bash
node /home/max/.claude/mowism/bin/mow-tools.cjs worktree verify-result "${PHASE_NUMBER}" \
  --tier "${TIER}" \
  --result "${OVERALL_RESULT}" \
  --blockers "${BLOCKERS_OR_NONE}"
```

This writes to the "Verification Results" section in STATE.md (implemented in Plan 02-01).

**Update the final report** to include the index file path:
```
Findings index: {phase_dir}/VERIFICATION-CHAIN-P{phase_number}.md
Findings detail: {phase_dir}/VERIFICATION-CHAIN-P{phase_number}/
STATE.md updated with verification results.
```

Per GATE-08: each check runs locally (already true -- Task() runs in same worktree). The orchestrator reads findings files after each Task() returns. The index file makes findings accessible to the orchestrator and future sessions.
  </action>
  <verify>
`grep "VERIFICATION-CHAIN-P" ~/.claude/mowism/workflows/refine-phase.md` shows index file generation.
`grep "verify-result" ~/.claude/mowism/workflows/refine-phase.md` shows STATE.md update call.
`grep "Overall Verdict" ~/.claude/mowism/workflows/refine-phase.md` shows verdict in index template.
  </verify>
  <done>
VERIFICATION-CHAIN index file is generated after chain completes with summary table and links. STATE.md is updated with verification results (tier, pass/fail, date, blockers). Each check runs locally with findings accessible to orchestrator via files.
  </done>
</task>

</tasks>

<verification>
- refine-phase workflow handles all 4 tiers (auto, minimum, complex, algorithmic)
- Complex tier has 3 parallel Task() calls (simplify, dead-code-sweep, grill-me)
- Algorithmic tier has 4 parallel Task() calls (adds prove-it)
- change-summary prompt includes reconciliation instructions
- VERIFICATION-CHAIN-P{phase}.md index is generated with summary table
- STATE.md is updated via `worktree verify-result` command
- Each check writes to its own findings file in the VERIFICATION-CHAIN directory
</verification>

<success_criteria>
User can run `/mow:refine-phase` with any tier and get: parallel quality checks (for complex/algorithmic), a VERIFICATION-CHAIN index file linking to all findings, STATE.md updated with results, and conflicting recommendations reconciled in change-summary.
</success_criteria>

<output>
After completion, create `.planning/phases/02-worktree-state-and-quality-gates/02-04-SUMMARY.md`
</output>
