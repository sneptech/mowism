---
phase: 07-state-coherence-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/mow-tools.cjs
  - bin/mow-tools.test.cjs
autonomous: true
requirements: [STATE-03]

must_haves:
  truths:
    - "Running `mow-tools.cjs message format plan_started --phase 7 --plan 07-01` produces valid JSON under 1KB with v, type, phase, plan, and ts fields"
    - "Running `mow-tools.cjs message format plan_complete --phase 7 --plan 07-01 --commit a1b2c3d --duration-min 3` produces JSON with all required fields for plan_complete"
    - "Running `mow-tools.cjs message parse '{...}'` validates the JSON against the schema and returns parsed fields or an error for invalid messages"
    - "Running `mow-tools.cjs chat-log append --from phase-07 --to phase-08 --msg 'test'` creates an NDJSON file at `.planning/chat-logs/phase-07-to-phase-08.ndjson`"
    - "All 7 event types (plan_started, plan_complete, phase_complete, error, blocker, state_change, ack) are supported by message format with correct required field validation"
  artifacts:
    - path: "bin/mow-tools.cjs"
      provides: "message format/parse and chat-log append/read/prune subcommands"
      contains: "cmdMessageFormat"
    - path: "bin/mow-tools.test.cjs"
      provides: "Tests for all message and chat-log subcommands"
      contains: "message format"
  key_links:
    - from: "bin/mow-tools.cjs cmdMessageFormat"
      to: "SendMessage content field"
      via: "produces JSON string that workers pass as SendMessage({ content: jsonString })"
      pattern: "JSON\\.stringify"
    - from: "bin/mow-tools.cjs cmdMessageParse"
      to: "coordinator message handler"
      via: "validates and extracts fields from incoming JSON messages"
      pattern: "JSON\\.parse"
---

<objective>
Implement the structured JSON message schema, format/parse CLI helpers, and peer chat log infrastructure in mow-tools.cjs.

Purpose: Workers and the coordinator need a well-defined message protocol to communicate state changes without writing to each other's files. Messages are JSON strings sent via the Agent Teams SendMessage tool. Chat logs provide an audit trail for peer-to-peer worker conversations.

Output: Message format/parse subcommands with schema validation for 7 event types, chat-log append/read/prune subcommands with NDJSON storage.
</objective>

<execution_context>
@~/.claude/mowism/workflows/execute-plan.md
@~/.claude/mowism/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-state-coherence-foundation/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement message format/parse and chat-log subcommands</name>
  <files>
    bin/mow-tools.cjs
  </files>
  <action>
  Add message and chat-log functions to `bin/mow-tools.cjs`, placed near the status functions.

  **Message Schema Constants:**

  Define at module scope (near other constants):

  ```javascript
  const MESSAGE_SCHEMA_VERSION = 1;

  const MESSAGE_REQUIRED_FIELDS = {
    plan_started: ['phase', 'plan'],
    plan_complete: ['phase', 'plan', 'commit', 'duration_min'],
    phase_complete: ['phase', 'plans_completed', 'total_duration_min'],
    error: ['phase', 'plan', 'error'],
    blocker: ['phase', 'plan', 'blocker', 'action'],
    state_change: ['phase', 'plan', 'from_state', 'to_state'],
    ack: ['ref_type', 'ref_plan'],
  };

  // VERBOSE VERSION (milestones + state transitions -- default)
  const ENABLED_EVENTS = ['plan_started', 'plan_complete', 'phase_complete', 'error', 'blocker', 'state_change', 'ack'];
  // LEAN VERSION (milestones only -- uncomment to switch)
  // const ENABLED_EVENTS = ['plan_complete', 'phase_complete', 'error', 'blocker', 'ack'];
  ```

  Per locked decision: ship verbose, keep lean commented out for easy toggling.

  **`cmdMessageFormat(type, fields, raw)`:**
  - Validates `type` is one of the known event types
  - Validates all required fields for that type are present in `fields`
  - Constructs message object: `{ v: MESSAGE_SCHEMA_VERSION, type, ts: new Date().toISOString(), ...fields }`
  - Serializes to JSON string
  - Checks size: if JSON.length > 1024, emit a warning on stderr but still output the message
  - If `raw`, output JSON string. Otherwise, output formatted with label.
  - The output is the JSON string ready to be used as SendMessage `content` field.

  **`cmdMessageParse(jsonString, raw)`:**
  - Attempts `JSON.parse(jsonString)`. On failure, error with "Invalid JSON".
  - Checks `v` field: if missing or not a number, warn "Missing schema version". If `v > MESSAGE_SCHEMA_VERSION`, warn "Unknown schema version {v}, attempting parse".
  - Checks `type` field exists and is known.
  - Validates required fields for the message type are present.
  - Returns parsed object as JSON (if raw) or formatted output.
  - Returns JSON: `{ valid: true, v, type, phase, plan, ts, ...rest }` or `{ valid: false, error: "..." }`

  **`cmdMessageSummary(type, fields)`:**
  - Helper function (not a CLI subcommand, called by format) that generates a 5-10 word summary string for the SendMessage `summary` field.
  - Pattern: `"Phase {phase}: {type description}"`
  - Examples:
    - `plan_started` -> `"Phase 7: plan 07-01 started"`
    - `plan_complete` -> `"Phase 7: plan 07-01 complete (3min)"`
    - `phase_complete` -> `"Phase 7: all plans complete"`
    - `error` -> `"Phase 7: error in 07-02"`
    - `blocker` -> `"Phase 7: blocker in 07-01 (skip)"`
    - `state_change` -> `"Phase 7: 07-01 in progress"`
    - `ack` -> `"Ack: plan_complete 07-01"`
  - When `--summary` flag is passed to `message format`, include the summary in output.

  **`cmdChatLogAppend(cwd, from, to, message, raw)`:**
  - Creates `.planning/chat-logs/` directory if it doesn't exist (using `fs.mkdirSync(dir, { recursive: true })`)
  - Sorts `[from, to]` alphabetically for deterministic filename: `{lower}-to-{higher}.ndjson`
  - Constructs entry: `{ from, to, ts: new Date().toISOString(), msg: message.slice(0, 500) }` (truncate at 500 chars per research)
  - Appends `JSON.stringify(entry) + '\n'` to the file using `fs.appendFileSync` (atomic for writes < PIPE_BUF on Linux)
  - Returns JSON: `{ appended: true, path: "...", entry_size: N }`

  **`cmdChatLogRead(cwd, from, to, raw)`:**
  - Resolves the same deterministic filename
  - Reads the NDJSON file, splits by newline, parses each line
  - Returns JSON array of entries

  **`cmdChatLogPrune(cwd, from, to, keep, raw)`:**
  - `keep` defaults to 200 (per research recommendation)
  - Reads the NDJSON file, keeps only the last `keep` lines, rewrites the file
  - Returns JSON: `{ pruned: true, before: N, after: M }`

  **CLI Routing** -- add two new cases in the `main()` switch block:

  ```javascript
  case 'message': {
    const subcommand = args[1];
    if (subcommand === 'format') {
      const type = args[2];
      // Collect all --key value pairs as fields
      const fields = {};
      for (let i = 3; i < args.length; i++) {
        if (args[i].startsWith('--') && args[i] !== '--raw' && args[i] !== '--summary') {
          const key = args[i].replace(/^--/, '').replace(/-/g, '_');
          fields[key] = args[i + 1];
          i++; // skip value
        }
      }
      const includeSummary = args.includes('--summary');
      cmdMessageFormat(type, fields, raw, includeSummary);
    } else if (subcommand === 'parse') {
      cmdMessageParse(args[2], raw);
    } else {
      error('Unknown message subcommand. Available: format, parse');
    }
    break;
  }

  case 'chat-log': {
    const subcommand = args[1];
    const fromIdx = args.indexOf('--from');
    const toIdx = args.indexOf('--to');
    if (subcommand === 'append') {
      const msgIdx = args.indexOf('--msg');
      cmdChatLogAppend(cwd,
        fromIdx !== -1 ? args[fromIdx + 1] : null,
        toIdx !== -1 ? args[toIdx + 1] : null,
        msgIdx !== -1 ? args[msgIdx + 1] : null,
        raw
      );
    } else if (subcommand === 'read') {
      cmdChatLogRead(cwd,
        fromIdx !== -1 ? args[fromIdx + 1] : null,
        toIdx !== -1 ? args[toIdx + 1] : null,
        raw
      );
    } else if (subcommand === 'prune') {
      const keepIdx = args.indexOf('--keep');
      cmdChatLogPrune(cwd,
        fromIdx !== -1 ? args[fromIdx + 1] : null,
        toIdx !== -1 ? args[toIdx + 1] : null,
        keepIdx !== -1 ? parseInt(args[keepIdx + 1], 10) : 200,
        raw
      );
    } else {
      error('Unknown chat-log subcommand. Available: append, read, prune');
    }
    break;
  }
  ```

  Update the top-level help string to include `message` and `chat-log` in the available commands list.
  </action>
  <verify>
  Run: `node bin/mow-tools.cjs message format plan_started --phase 7 --plan 07-01 --raw` and confirm valid JSON output with v, type, phase, plan, ts fields.
  Run: `node bin/mow-tools.cjs chat-log --raw` and confirm it shows available subcommands.
  </verify>
  <done>
  - 7 event types defined with required field validation
  - `message format` produces valid JSON under 1KB for all event types
  - `message parse` validates incoming JSON against schema and returns structured output
  - `chat-log append` creates NDJSON files with deterministic filenames in `.planning/chat-logs/`
  - `chat-log read` and `chat-log prune` work correctly
  - Verbose-to-lean toggle pattern: verbose default with commented-out lean version
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for message and chat-log subcommands</name>
  <files>
    bin/mow-tools.test.cjs
  </files>
  <action>
  Add test groups for message and chat-log subcommands in `bin/mow-tools.test.cjs`.

  **Message format tests (7 tests):**

  1. **`message format plan_started` produces valid JSON** -- Run `message format plan_started --phase 7 --plan 07-01 --raw`. Parse output. Assert: `v === 1`, `type === 'plan_started'`, `phase === '7'`, `plan === '07-01'`, `ts` is a valid ISO string.

  2. **`message format plan_complete` includes all required fields** -- Run with `--phase 7 --plan 07-01 --commit a1b2c3d --duration-min 3 --raw`. Assert: all fields present including `commit` and `duration_min`.

  3. **`message format` validates required fields** -- Run `message format plan_complete --phase 7 --raw` (missing plan, commit, duration_min). Assert: error output mentions missing fields.

  4. **`message format` rejects unknown event types** -- Run `message format unknown_type --phase 7 --raw`. Assert: error output.

  5. **`message format` all 7 types produce valid JSON** -- For each of: plan_started, plan_complete, phase_complete, error, blocker, state_change, ack, provide correct required fields. Assert all produce parseable JSON with correct `type` field.

  6. **`message format` with `--summary` includes summary string** -- Run `message format plan_complete --phase 7 --plan 07-01 --commit abc --duration-min 3 --summary --raw`. Assert output includes a `summary` field.

  7. **`message format` warns on messages over 1KB** -- Construct a message with a very long `error` field (~2000 chars). Assert: stderr contains a warning about exceeding 1KB, but the JSON is still output to stdout.

  **Message parse tests (4 tests):**

  8. **`message parse` validates good messages** -- Create a valid plan_started JSON string. Run `message parse '...' --raw`. Assert: `valid === true`, fields match input.

  9. **`message parse` rejects invalid JSON** -- Run `message parse 'not json' --raw`. Assert: error or `valid === false`.

  10. **`message parse` warns on unknown schema version** -- Create JSON with `v: 99`. Run parse. Assert: warning about unknown version, but still attempts parse.

  11. **`message parse` reports missing required fields** -- Create JSON with `type: 'plan_complete'` but missing `commit`. Run parse. Assert: `valid === false` with error about missing fields.

  **Chat-log tests (5 tests):**

  12. **`chat-log append` creates NDJSON file** -- Run `chat-log append --from phase-07 --to phase-08 --msg "test message"` in temp dir. Assert: file exists at `.planning/chat-logs/phase-07-to-phase-08.ndjson`, content is valid JSON with from, to, ts, msg fields.

  13. **`chat-log append` uses deterministic filename (sorted order)** -- Run `chat-log append --from phase-08 --to phase-07 --msg "reversed"`. Assert: file is still `phase-07-to-phase-08.ndjson` (lower sorts first).

  14. **`chat-log read` returns all entries** -- Append 3 entries. Run `chat-log read --from phase-07 --to phase-08 --raw`. Parse JSON array. Assert: 3 entries returned.

  15. **`chat-log prune` keeps only N most recent entries** -- Append 10 entries. Run `chat-log prune --from phase-07 --to phase-08 --keep 3 --raw`. Read file. Assert: 3 entries remain, they are the last 3 appended.

  16. **`chat-log append` truncates messages over 500 chars** -- Append a message of 600 characters. Read file. Assert: `msg` field is 500 chars.
  </action>
  <verify>
  Run the full test suite: `node bin/mow-tools.test.cjs`. All existing tests plus 16 new message/chat-log tests must pass.
  </verify>
  <done>
  - 16 tests covering message format, message parse, chat-log append, chat-log read, and chat-log prune
  - All tests pass (zero failures)
  - Existing tests unaffected (regression-safe)
  </done>
</task>

</tasks>

<verification>
1. `node bin/mow-tools.cjs message format plan_started --phase 7 --plan 07-01 --raw` produces valid JSON under 1KB
2. `node bin/mow-tools.cjs message parse '{"v":1,"type":"plan_started","phase":"7","plan":"07-01","ts":"2026-02-20T10:00:00Z"}' --raw` returns `valid: true`
3. `node bin/mow-tools.cjs chat-log append --from phase-07 --to phase-08 --msg "test" --raw` creates NDJSON file
4. `node bin/mow-tools.test.cjs` passes all tests
5. All 7 event types are supported with correct required field validation
</verification>

<success_criteria>
- Message format produces valid JSON for all 7 event types with schema version, type, timestamp, and required fields
- Message parse validates incoming JSON and reports missing/invalid fields
- Chat-log append creates NDJSON files with deterministic filenames and 500-char message truncation
- Chat-log prune keeps configurable N most recent entries (default 200)
- Verbose-to-lean event toggle pattern ships as default (state transitions enabled) with lean version commented out
- All messages under 1KB for typical payloads (with warning if exceeded)
</success_criteria>

<output>
After completion, create `.planning/phases/07-state-coherence-foundation/07-02-SUMMARY.md`
</output>
