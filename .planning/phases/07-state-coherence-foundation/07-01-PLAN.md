---
phase: 07-state-coherence-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mowism/templates/status.md
  - bin/mow-tools.cjs
  - bin/mow-tools.test.cjs
autonomous: true
requirements: [STATE-02]

must_haves:
  truths:
    - "Running `mow-tools.cjs status init 7` creates a valid STATUS.md in the phase directory with the correct template structure"
    - "Running `mow-tools.cjs status write 7 --plan 07-01 --status in_progress` updates exactly one row in the Plan Progress table without corrupting other rows"
    - "Running `mow-tools.cjs status read 7` returns valid JSON with plan progress rows, metadata fields, and aggregate counts"
    - "Running `mow-tools.cjs status aggregate 7` recalculates the Aggregate section to match the Plan Progress table data"
  artifacts:
    - path: "mowism/templates/status.md"
      provides: "STATUS.md template with machine-parseable format"
      contains: "## Plan Progress"
    - path: "bin/mow-tools.cjs"
      provides: "status init/read/write/aggregate subcommands"
      contains: "cmdStatusInit"
    - path: "bin/mow-tools.test.cjs"
      provides: "Tests for all four status subcommands"
      contains: "status init"
  key_links:
    - from: "bin/mow-tools.cjs cmdStatusInit"
      to: "mowism/templates/status.md"
      via: "reads template, fills phase metadata, writes to phase directory"
      pattern: "templates/status\\.md"
    - from: "bin/mow-tools.cjs cmdStatusWrite"
      to: "phases/XX/XX-STATUS.md"
      via: "parsePlanProgressTable -> update row -> rewrite section"
      pattern: "parsePlanProgressTable"
---

<objective>
Create the per-phase STATUS.md file format, template, and mow-tools.cjs CLI subcommands for isolated phase worker status tracking.

Purpose: Workers need an isolated file per phase to write execution progress without touching other workers' files or the coordinator's STATE.md. This is the foundational building block for the single-writer protocol.

Output: STATUS.md template, four new mow-tools.cjs subcommands (`status init`, `status read`, `status write`, `status aggregate`), and tests.
</objective>

<execution_context>
@~/.claude/mowism/workflows/execute-plan.md
@~/.claude/mowism/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-state-coherence-foundation/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create STATUS.md template and status CLI subcommands</name>
  <files>
    mowism/templates/status.md
    bin/mow-tools.cjs
  </files>
  <action>
  **1. Create `mowism/templates/status.md`** with the machine-parseable format from research:

  ```markdown
  # Phase {phase_number}: {phase_name} -- Status

  **Phase:** {phase_number}
  **Status:** not started
  **Worker:** --
  **Worktree:** --
  **Started:** --
  **Last update:** --
  **Blocker mode:** skip

  ## Plan Progress

  | Plan | Status | Started | Duration | Commit | Tasks |
  |------|--------|---------|----------|--------|-------|

  ## Aggregate

  **Plans:** 0 complete, 0 in progress, 0 not started, 0 failed
  **Commits:** --

  ## Blockers

  None.

  ## Decisions

  None.

  ## Context

  None.
  ```

  Use bold-field patterns (`**Field:** value`) that match the existing `stateExtractField()` function in mow-tools.cjs (line ~1394). Plan Progress table uses the same `|`-delimited format as worktree and teammate tables.

  Status values are discrete strings per locked decision: `not started`, `in progress`, `complete`, `failed` (no percentages).

  **2. Add four new functions to `bin/mow-tools.cjs`:**

  Place them near the existing state management functions (after the `cmdStateSnapshot` function, around line 2160).

  **`cmdStatusInit(cwd, phase, raw)`:**
  - Uses `findPhaseDir(cwd, phase)` to resolve the phase directory
  - Reads the template from `mowism/templates/status.md` using the standard Mowism install path resolution (check `~/.claude/mowism/templates/` and fall back to repo-relative `mowism/templates/`)
  - Fills `{phase_number}` and `{phase_name}` placeholders from the phase directory name
  - Scans for `*-PLAN.md` files in the phase directory and pre-populates the Plan Progress table with one row per plan, all set to `not started`, tasks column derived from counting `<task` elements in each plan
  - Writes to `{phaseDir}/{padded_phase}-STATUS.md`
  - Convention-based discovery path: `phases/{padded}-{slug}/{padded}-STATUS.md`
  - Returns JSON: `{ created: true, path: "...", plans: N }`

  **`cmdStatusRead(cwd, phase, raw)`:**
  - Uses `findPhaseDir(cwd, phase)` + convention `{padded}-STATUS.md`
  - Reads the STATUS.md file
  - Extracts bold-field metadata using existing `stateExtractField()` pattern
  - Parses Plan Progress table using pattern adapted from `parseWorktreeTable()` (line ~5199)
  - Calculates aggregate from Plan Progress data
  - Returns JSON: `{ phase, status, worker, worktree, started, last_update, blocker_mode, plans: [{plan, status, started, duration, commit, tasks}], aggregate: {complete: N, in_progress: N, not_started: N, failed: N}, blockers: [...], decisions: [...] }`

  **`cmdStatusWrite(cwd, phase, options, raw)`:**
  - Options: `--plan <id> --status <state> [--commit <sha>] [--duration <min>] [--tasks <progress>]`
  - Reads existing STATUS.md, parses Plan Progress table
  - Finds the matching row by plan ID, updates only the specified fields (keeps existing values for unspecified fields)
  - If `--status` transitions from `not started` to `in progress`, set `Started` to current short time (HH:MM)
  - If `--status` transitions to `complete`, set `Duration` from start time
  - Rewrites the Plan Progress table section
  - Updates `**Last update:**` to current ISO timestamp
  - Updates `**Status:**` metadata: if any plan is `in progress`, phase status = `executing`; if all complete, phase status = `complete`
  - Auto-calls aggregate recalculation
  - Returns JSON: `{ updated: true, plan: "...", new_status: "..." }`

  **`cmdStatusAggregate(cwd, phase, raw)`:**
  - Reads STATUS.md, parses Plan Progress table
  - Counts plans by status: complete, in progress, not started, failed
  - Collects all non-empty commit SHAs from complete plans
  - Rewrites `## Aggregate` section with updated counts and commit list
  - Returns JSON with counts

  **3. Add CLI routing** in the `main()` switch block (after the `worktree` case, around line 5768):

  ```javascript
  case 'status': {
    const subcommand = args[1];
    if (subcommand === 'init') {
      cmdStatusInit(cwd, args[2], raw);
    } else if (subcommand === 'read') {
      cmdStatusRead(cwd, args[2], raw);
    } else if (subcommand === 'write') {
      const planIdx = args.indexOf('--plan');
      const statusIdx = args.indexOf('--status');
      const commitIdx = args.indexOf('--commit');
      const durationIdx = args.indexOf('--duration');
      const tasksIdx = args.indexOf('--tasks');
      cmdStatusWrite(cwd, args[2], {
        plan: planIdx !== -1 ? args[planIdx + 1] : null,
        status: statusIdx !== -1 ? args[statusIdx + 1] : null,
        commit: commitIdx !== -1 ? args[commitIdx + 1] : null,
        duration: durationIdx !== -1 ? args[durationIdx + 1] : null,
        tasks: tasksIdx !== -1 ? args[tasksIdx + 1] : null,
      }, raw);
    } else if (subcommand === 'aggregate') {
      cmdStatusAggregate(cwd, args[2], raw);
    } else {
      error('Unknown status subcommand. Available: init, read, write, aggregate');
    }
    break;
  }
  ```

  Also update the top-level help string to include `status` in the available commands list.
  </action>
  <verify>
  Run `node bin/mow-tools.cjs status --raw` and confirm it shows the help message with available subcommands.
  Verify the template file exists: `ls mowism/templates/status.md`.
  </verify>
  <done>
  - STATUS.md template file exists at `mowism/templates/status.md` with bold-field metadata, Plan Progress table, Aggregate, Blockers, Decisions, and Context sections
  - Four functions exist in mow-tools.cjs: cmdStatusInit, cmdStatusRead, cmdStatusWrite, cmdStatusAggregate
  - CLI routing handles `status init|read|write|aggregate` subcommands
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for status subcommands</name>
  <files>
    bin/mow-tools.test.cjs
  </files>
  <action>
  Add a new test group for the status subcommands in `bin/mow-tools.test.cjs`. Follow the existing test patterns in the file (using the `test()` helper function and `tmpDir` setup).

  **Tests to add (8 tests minimum):**

  1. **`status init` creates STATUS.md from template** -- Set up a temp `.planning/phases/07-test-phase/` directory with a mock `07-01-PLAN.md` (containing 2 `<task` elements) and a `07-02-PLAN.md` (containing 3 `<task` elements). Run `status init 7`. Assert: `07-STATUS.md` exists, contains `**Phase:** 7`, contains a Plan Progress table with 2 rows (07-01 and 07-02), both with status `not started`, tasks columns showing `0/2` and `0/3`.

  2. **`status init` fails gracefully for missing phase** -- Run `status init 99`. Assert: error output mentions "phase" not found.

  3. **`status read` parses STATUS.md correctly** -- Create a STATUS.md with known content (2 plans: one complete, one in progress). Run `status read 7 --raw`. Parse JSON output. Assert: `status === 'executing'`, `plans.length === 2`, first plan has `status: 'complete'`, aggregate counts match.

  4. **`status write` updates a single plan row** -- Create an initialized STATUS.md. Run `status write 7 --plan 07-01 --status "in progress"`. Read STATUS.md. Assert: 07-01 row shows `in progress`, 07-02 row unchanged at `not started`. `**Last update:**` has a timestamp. `**Status:**` is `executing`.

  5. **`status write` handles plan completion with commit SHA** -- Starting from an in-progress STATUS.md. Run `status write 7 --plan 07-01 --status complete --commit a1b2c3d --duration 3min`. Assert: 07-01 row shows `complete`, commit is `a1b2c3d`, duration is `3min`.

  6. **`status write` fails for unknown plan** -- Run `status write 7 --plan 07-99 --status "in progress"`. Assert: error mentions plan not found.

  7. **`status aggregate` recalculates counts** -- Create STATUS.md with known plan rows (1 complete, 1 in progress, 1 not started). Run `status aggregate 7 --raw`. Parse JSON. Assert: `complete: 1, in_progress: 1, not_started: 1, failed: 0`.

  8. **`status write` updates phase status to complete when all plans complete** -- Create STATUS.md with 2 plans. Write both to `complete`. Assert: `**Status:**` field reads `complete`.

  Use the existing test file structure: create temp directories, populate with fixture files, run commands, assert outcomes, clean up.
  </action>
  <verify>
  Run the full test suite: `node bin/mow-tools.test.cjs`. All existing tests plus 8+ new status tests must pass.
  </verify>
  <done>
  - 8+ tests covering status init, read, write, and aggregate subcommands
  - All tests pass (zero failures)
  - Existing tests unaffected (regression-safe)
  </done>
</task>

</tasks>

<verification>
1. `node bin/mow-tools.cjs status init 7 --raw` creates a STATUS.md in the current project's phase 7 directory (will need a temp test setup or existing phase dir)
2. `node bin/mow-tools.test.cjs` passes all tests including the new status group
3. `mowism/templates/status.md` contains the documented template format
4. STATUS.md file format matches the research specification: bold-field metadata, Plan Progress table with 6 columns, Aggregate section, Blockers, Decisions, Context
</verification>

<success_criteria>
- Per-phase STATUS.md template exists and matches the machine-parseable format from research
- Four CLI subcommands (status init/read/write/aggregate) work correctly
- 8+ tests validate all subcommands
- STATUS.md files use convention-based discovery: `phases/{padded}-{slug}/{padded}-STATUS.md`
- Plan status values are discrete: not started / in progress / complete / failed (no percentages)
</success_criteria>

<output>
After completion, create `.planning/phases/07-state-coherence-foundation/07-01-SUMMARY.md`
</output>
